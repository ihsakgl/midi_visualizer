import numpy as np

from typing import (
    Any,
    overload,
    Sequence,
    Tuple,
)

Mat = np.ndarray
Rect = Sequence[int]
Size = Sequence[int]
Size2f = Sequence[float]
UMat = np.ndarray

# cv.gapi.ie
TraitAs_IMAGE: int
TraitAs_TENSOR: int

# cv.gapi.video
TYPE_BS_KNN: int
TYPE_BS_MOG2: int

# cv.gapi.core.fluid

# cv.utils

# cv.gapi.core.ocl

# cv
ACCESS_FAST: int
ACCESS_MASK: int
ACCESS_READ: int
ACCESS_RW: int
ACCESS_WRITE: int
ADAPTIVE_THRESH_GAUSSIAN_C: int
ADAPTIVE_THRESH_MEAN_C: int
AKAZE_DESCRIPTOR_KAZE: int
AKAZE_DESCRIPTOR_KAZE_UPRIGHT: int
AKAZE_DESCRIPTOR_MLDB: int
AKAZE_DESCRIPTOR_MLDB_UPRIGHT: int
AgastFeatureDetector_AGAST_5_8: int
AgastFeatureDetector_AGAST_7_12d: int
AgastFeatureDetector_AGAST_7_12s: int
AgastFeatureDetector_NONMAX_SUPPRESSION: int
AgastFeatureDetector_OAST_9_16: int
AgastFeatureDetector_THRESHOLD: int
BORDER_CONSTANT: int
BORDER_DEFAULT: int
BORDER_ISOLATED: int
BORDER_REFLECT: int
BORDER_REFLECT101: int
BORDER_REFLECT_101: int
BORDER_REPLICATE: int
BORDER_TRANSPARENT: int
BORDER_WRAP: int
CALIB_CB_ACCURACY: int
CALIB_CB_ADAPTIVE_THRESH: int
CALIB_CB_ASYMMETRIC_GRID: int
CALIB_CB_CLUSTERING: int
CALIB_CB_EXHAUSTIVE: int
CALIB_CB_FAST_CHECK: int
CALIB_CB_FILTER_QUADS: int
CALIB_CB_LARGER: int
CALIB_CB_MARKER: int
CALIB_CB_NORMALIZE_IMAGE: int
CALIB_CB_SYMMETRIC_GRID: int
CALIB_FIX_ASPECT_RATIO: int
CALIB_FIX_FOCAL_LENGTH: int
CALIB_FIX_INTRINSIC: int
CALIB_FIX_K1: int
CALIB_FIX_K2: int
CALIB_FIX_K3: int
CALIB_FIX_K4: int
CALIB_FIX_K5: int
CALIB_FIX_K6: int
CALIB_FIX_PRINCIPAL_POINT: int
CALIB_FIX_S1_S2_S3_S4: int
CALIB_FIX_TANGENT_DIST: int
CALIB_FIX_TAUX_TAUY: int
CALIB_HAND_EYE_ANDREFF: int
CALIB_HAND_EYE_DANIILIDIS: int
CALIB_HAND_EYE_HORAUD: int
CALIB_HAND_EYE_PARK: int
CALIB_HAND_EYE_TSAI: int
CALIB_NINTRINSIC: int
CALIB_RATIONAL_MODEL: int
CALIB_ROBOT_WORLD_HAND_EYE_LI: int
CALIB_ROBOT_WORLD_HAND_EYE_SHAH: int
CALIB_SAME_FOCAL_LENGTH: int
CALIB_THIN_PRISM_MODEL: int
CALIB_TILTED_MODEL: int
CALIB_USE_EXTRINSIC_GUESS: int
CALIB_USE_INTRINSIC_GUESS: int
CALIB_USE_LU: int
CALIB_USE_QR: int
CALIB_ZERO_DISPARITY: int
CALIB_ZERO_TANGENT_DIST: int
CAP_ANDROID: int
CAP_ANY: int
CAP_ARAVIS: int
CAP_AVFOUNDATION: int
CAP_CMU1394: int
CAP_DC1394: int
CAP_DSHOW: int
CAP_FFMPEG: int
CAP_FIREWARE: int
CAP_FIREWIRE: int
CAP_GIGANETIX: int
CAP_GPHOTO2: int
CAP_GSTREAMER: int
CAP_IEEE1394: int
CAP_IMAGES: int
CAP_INTELPERC: int
CAP_INTELPERC_DEPTH_GENERATOR: int
CAP_INTELPERC_DEPTH_MAP: int
CAP_INTELPERC_GENERATORS_MASK: int
CAP_INTELPERC_IMAGE: int
CAP_INTELPERC_IMAGE_GENERATOR: int
CAP_INTELPERC_IR_GENERATOR: int
CAP_INTELPERC_IR_MAP: int
CAP_INTELPERC_UVDEPTH_MAP: int
CAP_INTEL_MFX: int
CAP_MSMF: int
CAP_OPENCV_MJPEG: int
CAP_OPENNI: int
CAP_OPENNI2: int
CAP_OPENNI2_ASTRA: int
CAP_OPENNI2_ASUS: int
CAP_OPENNI_ASUS: int
CAP_OPENNI_BGR_IMAGE: int
CAP_OPENNI_DEPTH_GENERATOR: int
CAP_OPENNI_DEPTH_GENERATOR_BASELINE: int
CAP_OPENNI_DEPTH_GENERATOR_FOCAL_LENGTH: int
CAP_OPENNI_DEPTH_GENERATOR_PRESENT: int
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION: int
CAP_OPENNI_DEPTH_GENERATOR_REGISTRATION_ON: int
CAP_OPENNI_DEPTH_MAP: int
CAP_OPENNI_DISPARITY_MAP: int
CAP_OPENNI_DISPARITY_MAP_32F: int
CAP_OPENNI_GENERATORS_MASK: int
CAP_OPENNI_GRAY_IMAGE: int
CAP_OPENNI_IMAGE_GENERATOR: int
CAP_OPENNI_IMAGE_GENERATOR_OUTPUT_MODE: int
CAP_OPENNI_IMAGE_GENERATOR_PRESENT: int
CAP_OPENNI_IR_GENERATOR: int
CAP_OPENNI_IR_GENERATOR_PRESENT: int
CAP_OPENNI_IR_IMAGE: int
CAP_OPENNI_POINT_CLOUD_MAP: int
CAP_OPENNI_QVGA_30HZ: int
CAP_OPENNI_QVGA_60HZ: int
CAP_OPENNI_SXGA_15HZ: int
CAP_OPENNI_SXGA_30HZ: int
CAP_OPENNI_VALID_DEPTH_MASK: int
CAP_OPENNI_VGA_30HZ: int
CAP_PROP_APERTURE: int
CAP_PROP_ARAVIS_AUTOTRIGGER: int
CAP_PROP_AUTOFOCUS: int
CAP_PROP_AUTO_EXPOSURE: int
CAP_PROP_AUTO_WB: int
CAP_PROP_BACKEND: int
CAP_PROP_BACKLIGHT: int
CAP_PROP_BITRATE: int
CAP_PROP_BRIGHTNESS: int
CAP_PROP_BUFFERSIZE: int
CAP_PROP_CHANNEL: int
CAP_PROP_CODEC_PIXEL_FORMAT: int
CAP_PROP_CONTRAST: int
CAP_PROP_CONVERT_RGB: int
CAP_PROP_DC1394_MAX: int
CAP_PROP_DC1394_MODE_AUTO: int
CAP_PROP_DC1394_MODE_MANUAL: int
CAP_PROP_DC1394_MODE_ONE_PUSH_AUTO: int
CAP_PROP_DC1394_OFF: int
CAP_PROP_EXPOSURE: int
CAP_PROP_EXPOSUREPROGRAM: int
CAP_PROP_FOCUS: int
CAP_PROP_FORMAT: int
CAP_PROP_FOURCC: int
CAP_PROP_FPS: int
CAP_PROP_FRAME_COUNT: int
CAP_PROP_FRAME_HEIGHT: int
CAP_PROP_FRAME_WIDTH: int
CAP_PROP_GAIN: int
CAP_PROP_GAMMA: int
CAP_PROP_GIGA_FRAME_HEIGH_MAX: int
CAP_PROP_GIGA_FRAME_OFFSET_X: int
CAP_PROP_GIGA_FRAME_OFFSET_Y: int
CAP_PROP_GIGA_FRAME_SENS_HEIGH: int
CAP_PROP_GIGA_FRAME_SENS_WIDTH: int
CAP_PROP_GIGA_FRAME_WIDTH_MAX: int
CAP_PROP_GPHOTO2_COLLECT_MSGS: int
CAP_PROP_GPHOTO2_FLUSH_MSGS: int
CAP_PROP_GPHOTO2_PREVIEW: int
CAP_PROP_GPHOTO2_RELOAD_CONFIG: int
CAP_PROP_GPHOTO2_RELOAD_ON_CHANGE: int
CAP_PROP_GPHOTO2_WIDGET_ENUMERATE: int
CAP_PROP_GSTREAMER_QUEUE_LENGTH: int
CAP_PROP_GUID: int
CAP_PROP_HUE: int
CAP_PROP_HW_ACCELERATION: int
CAP_PROP_HW_ACCELERATION_USE_OPENCL: int
CAP_PROP_HW_DEVICE: int
CAP_PROP_IMAGES_BASE: int
CAP_PROP_IMAGES_LAST: int
CAP_PROP_INTELPERC_DEPTH_CONFIDENCE_THRESHOLD: int
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_HORZ: int
CAP_PROP_INTELPERC_DEPTH_FOCAL_LENGTH_VERT: int
CAP_PROP_INTELPERC_DEPTH_LOW_CONFIDENCE_VALUE: int
CAP_PROP_INTELPERC_DEPTH_SATURATION_VALUE: int
CAP_PROP_INTELPERC_PROFILE_COUNT: int
CAP_PROP_INTELPERC_PROFILE_IDX: int
CAP_PROP_IOS_DEVICE_EXPOSURE: int
CAP_PROP_IOS_DEVICE_FLASH: int
CAP_PROP_IOS_DEVICE_FOCUS: int
CAP_PROP_IOS_DEVICE_TORCH: int
CAP_PROP_IOS_DEVICE_WHITEBALANCE: int
CAP_PROP_IRIS: int
CAP_PROP_ISO_SPEED: int
CAP_PROP_MODE: int
CAP_PROP_MONOCHROME: int
CAP_PROP_OPENNI2_MIRROR: int
CAP_PROP_OPENNI2_SYNC: int
CAP_PROP_OPENNI_APPROX_FRAME_SYNC: int
CAP_PROP_OPENNI_BASELINE: int
CAP_PROP_OPENNI_CIRCLE_BUFFER: int
CAP_PROP_OPENNI_FOCAL_LENGTH: int
CAP_PROP_OPENNI_FRAME_MAX_DEPTH: int
CAP_PROP_OPENNI_GENERATOR_PRESENT: int
CAP_PROP_OPENNI_MAX_BUFFER_SIZE: int
CAP_PROP_OPENNI_MAX_TIME_DURATION: int
CAP_PROP_OPENNI_OUTPUT_MODE: int
CAP_PROP_OPENNI_REGISTRATION: int
CAP_PROP_OPENNI_REGISTRATION_ON: int
CAP_PROP_ORIENTATION_AUTO: int
CAP_PROP_ORIENTATION_META: int
CAP_PROP_PAN: int
CAP_PROP_POS_AVI_RATIO: int
CAP_PROP_POS_FRAMES: int
CAP_PROP_POS_MSEC: int
CAP_PROP_PVAPI_BINNINGX: int
CAP_PROP_PVAPI_BINNINGY: int
CAP_PROP_PVAPI_DECIMATIONHORIZONTAL: int
CAP_PROP_PVAPI_DECIMATIONVERTICAL: int
CAP_PROP_PVAPI_FRAMESTARTTRIGGERMODE: int
CAP_PROP_PVAPI_MULTICASTIP: int
CAP_PROP_PVAPI_PIXELFORMAT: int
CAP_PROP_RECTIFICATION: int
CAP_PROP_ROLL: int
CAP_PROP_SAR_DEN: int
CAP_PROP_SAR_NUM: int
CAP_PROP_SATURATION: int
CAP_PROP_SETTINGS: int
CAP_PROP_SHARPNESS: int
CAP_PROP_SPEED: int
CAP_PROP_TEMPERATURE: int
CAP_PROP_TILT: int
CAP_PROP_TRIGGER: int
CAP_PROP_TRIGGER_DELAY: int
CAP_PROP_VIEWFINDER: int
CAP_PROP_WB_TEMPERATURE: int
CAP_PROP_WHITE_BALANCE_BLUE_U: int
CAP_PROP_WHITE_BALANCE_RED_V: int
CAP_PROP_XI_ACQ_BUFFER_SIZE: int
CAP_PROP_XI_ACQ_BUFFER_SIZE_UNIT: int
CAP_PROP_XI_ACQ_FRAME_BURST_COUNT: int
CAP_PROP_XI_ACQ_TIMING_MODE: int
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_COMMIT: int
CAP_PROP_XI_ACQ_TRANSPORT_BUFFER_SIZE: int
CAP_PROP_XI_AEAG: int
CAP_PROP_XI_AEAG_LEVEL: int
CAP_PROP_XI_AEAG_ROI_HEIGHT: int
CAP_PROP_XI_AEAG_ROI_OFFSET_X: int
CAP_PROP_XI_AEAG_ROI_OFFSET_Y: int
CAP_PROP_XI_AEAG_ROI_WIDTH: int
CAP_PROP_XI_AE_MAX_LIMIT: int
CAP_PROP_XI_AG_MAX_LIMIT: int
CAP_PROP_XI_APPLY_CMS: int
CAP_PROP_XI_AUTO_BANDWIDTH_CALCULATION: int
CAP_PROP_XI_AUTO_WB: int
CAP_PROP_XI_AVAILABLE_BANDWIDTH: int
CAP_PROP_XI_BINNING_HORIZONTAL: int
CAP_PROP_XI_BINNING_PATTERN: int
CAP_PROP_XI_BINNING_SELECTOR: int
CAP_PROP_XI_BINNING_VERTICAL: int
CAP_PROP_XI_BPC: int
CAP_PROP_XI_BUFFERS_QUEUE_SIZE: int
CAP_PROP_XI_BUFFER_POLICY: int
CAP_PROP_XI_CC_MATRIX_00: int
CAP_PROP_XI_CC_MATRIX_01: int
CAP_PROP_XI_CC_MATRIX_02: int
CAP_PROP_XI_CC_MATRIX_03: int
CAP_PROP_XI_CC_MATRIX_10: int
CAP_PROP_XI_CC_MATRIX_11: int
CAP_PROP_XI_CC_MATRIX_12: int
CAP_PROP_XI_CC_MATRIX_13: int
CAP_PROP_XI_CC_MATRIX_20: int
CAP_PROP_XI_CC_MATRIX_21: int
CAP_PROP_XI_CC_MATRIX_22: int
CAP_PROP_XI_CC_MATRIX_23: int
CAP_PROP_XI_CC_MATRIX_30: int
CAP_PROP_XI_CC_MATRIX_31: int
CAP_PROP_XI_CC_MATRIX_32: int
CAP_PROP_XI_CC_MATRIX_33: int
CAP_PROP_XI_CHIP_TEMP: int
CAP_PROP_XI_CMS: int
CAP_PROP_XI_COLOR_FILTER_ARRAY: int
CAP_PROP_XI_COLUMN_FPN_CORRECTION: int
CAP_PROP_XI_COOLING: int
CAP_PROP_XI_COUNTER_SELECTOR: int
CAP_PROP_XI_COUNTER_VALUE: int
CAP_PROP_XI_DATA_FORMAT: int
CAP_PROP_XI_DEBOUNCE_EN: int
CAP_PROP_XI_DEBOUNCE_POL: int
CAP_PROP_XI_DEBOUNCE_T0: int
CAP_PROP_XI_DEBOUNCE_T1: int
CAP_PROP_XI_DEBUG_LEVEL: int
CAP_PROP_XI_DECIMATION_HORIZONTAL: int
CAP_PROP_XI_DECIMATION_PATTERN: int
CAP_PROP_XI_DECIMATION_SELECTOR: int
CAP_PROP_XI_DECIMATION_VERTICAL: int
CAP_PROP_XI_DEFAULT_CC_MATRIX: int
CAP_PROP_XI_DEVICE_MODEL_ID: int
CAP_PROP_XI_DEVICE_RESET: int
CAP_PROP_XI_DEVICE_SN: int
CAP_PROP_XI_DOWNSAMPLING: int
CAP_PROP_XI_DOWNSAMPLING_TYPE: int
CAP_PROP_XI_EXPOSURE: int
CAP_PROP_XI_EXPOSURE_BURST_COUNT: int
CAP_PROP_XI_EXP_PRIORITY: int
CAP_PROP_XI_FFS_ACCESS_KEY: int
CAP_PROP_XI_FFS_FILE_ID: int
CAP_PROP_XI_FFS_FILE_SIZE: int
CAP_PROP_XI_FRAMERATE: int
CAP_PROP_XI_FREE_FFS_SIZE: int
CAP_PROP_XI_GAIN: int
CAP_PROP_XI_GAIN_SELECTOR: int
CAP_PROP_XI_GAMMAC: int
CAP_PROP_XI_GAMMAY: int
CAP_PROP_XI_GPI_LEVEL: int
CAP_PROP_XI_GPI_MODE: int
CAP_PROP_XI_GPI_SELECTOR: int
CAP_PROP_XI_GPO_MODE: int
CAP_PROP_XI_GPO_SELECTOR: int
CAP_PROP_XI_HDR: int
CAP_PROP_XI_HDR_KNEEPOINT_COUNT: int
CAP_PROP_XI_HDR_T1: int
CAP_PROP_XI_HDR_T2: int
CAP_PROP_XI_HEIGHT: int
CAP_PROP_XI_HOUS_BACK_SIDE_TEMP: int
CAP_PROP_XI_HOUS_TEMP: int
CAP_PROP_XI_HW_REVISION: int
CAP_PROP_XI_IMAGE_BLACK_LEVEL: int
CAP_PROP_XI_IMAGE_DATA_BIT_DEPTH: int
CAP_PROP_XI_IMAGE_DATA_FORMAT: int
CAP_PROP_XI_IMAGE_DATA_FORMAT_RGB32_ALPHA: int
CAP_PROP_XI_IMAGE_IS_COLOR: int
CAP_PROP_XI_IMAGE_PAYLOAD_SIZE: int
CAP_PROP_XI_IS_COOLED: int
CAP_PROP_XI_IS_DEVICE_EXIST: int
CAP_PROP_XI_KNEEPOINT1: int
CAP_PROP_XI_KNEEPOINT2: int
CAP_PROP_XI_LED_MODE: int
CAP_PROP_XI_LED_SELECTOR: int
CAP_PROP_XI_LENS_APERTURE_VALUE: int
CAP_PROP_XI_LENS_FEATURE: int
CAP_PROP_XI_LENS_FEATURE_SELECTOR: int
CAP_PROP_XI_LENS_FOCAL_LENGTH: int
CAP_PROP_XI_LENS_FOCUS_DISTANCE: int
CAP_PROP_XI_LENS_FOCUS_MOVE: int
CAP_PROP_XI_LENS_FOCUS_MOVEMENT_VALUE: int
CAP_PROP_XI_LENS_MODE: int
CAP_PROP_XI_LIMIT_BANDWIDTH: int
CAP_PROP_XI_LUT_EN: int
CAP_PROP_XI_LUT_INDEX: int
CAP_PROP_XI_LUT_VALUE: int
CAP_PROP_XI_MANUAL_WB: int
CAP_PROP_XI_OFFSET_X: int
CAP_PROP_XI_OFFSET_Y: int
CAP_PROP_XI_OUTPUT_DATA_BIT_DEPTH: int
CAP_PROP_XI_OUTPUT_DATA_PACKING: int
CAP_PROP_XI_OUTPUT_DATA_PACKING_TYPE: int
CAP_PROP_XI_RECENT_FRAME: int
CAP_PROP_XI_REGION_MODE: int
CAP_PROP_XI_REGION_SELECTOR: int
CAP_PROP_XI_ROW_FPN_CORRECTION: int
CAP_PROP_XI_SENSOR_BOARD_TEMP: int
CAP_PROP_XI_SENSOR_CLOCK_FREQ_HZ: int
CAP_PROP_XI_SENSOR_CLOCK_FREQ_INDEX: int
CAP_PROP_XI_SENSOR_DATA_BIT_DEPTH: int
CAP_PROP_XI_SENSOR_FEATURE_SELECTOR: int
CAP_PROP_XI_SENSOR_FEATURE_VALUE: int
CAP_PROP_XI_SENSOR_MODE: int
CAP_PROP_XI_SENSOR_OUTPUT_CHANNEL_COUNT: int
CAP_PROP_XI_SENSOR_TAPS: int
CAP_PROP_XI_SHARPNESS: int
CAP_PROP_XI_SHUTTER_TYPE: int
CAP_PROP_XI_TARGET_TEMP: int
CAP_PROP_XI_TEST_PATTERN: int
CAP_PROP_XI_TEST_PATTERN_GENERATOR_SELECTOR: int
CAP_PROP_XI_TIMEOUT: int
CAP_PROP_XI_TRANSPORT_PIXEL_FORMAT: int
CAP_PROP_XI_TRG_DELAY: int
CAP_PROP_XI_TRG_SELECTOR: int
CAP_PROP_XI_TRG_SOFTWARE: int
CAP_PROP_XI_TRG_SOURCE: int
CAP_PROP_XI_TS_RST_MODE: int
CAP_PROP_XI_TS_RST_SOURCE: int
CAP_PROP_XI_USED_FFS_SIZE: int
CAP_PROP_XI_WB_KB: int
CAP_PROP_XI_WB_KG: int
CAP_PROP_XI_WB_KR: int
CAP_PROP_XI_WIDTH: int
CAP_PROP_ZOOM: int
CAP_PVAPI: int
CAP_PVAPI_DECIMATION_2OUTOF16: int
CAP_PVAPI_DECIMATION_2OUTOF4: int
CAP_PVAPI_DECIMATION_2OUTOF8: int
CAP_PVAPI_DECIMATION_OFF: int
CAP_PVAPI_FSTRIGMODE_FIXEDRATE: int
CAP_PVAPI_FSTRIGMODE_FREERUN: int
CAP_PVAPI_FSTRIGMODE_SOFTWARE: int
CAP_PVAPI_FSTRIGMODE_SYNCIN1: int
CAP_PVAPI_FSTRIGMODE_SYNCIN2: int
CAP_PVAPI_PIXELFORMAT_BAYER16: int
CAP_PVAPI_PIXELFORMAT_BAYER8: int
CAP_PVAPI_PIXELFORMAT_BGR24: int
CAP_PVAPI_PIXELFORMAT_BGRA32: int
CAP_PVAPI_PIXELFORMAT_MONO16: int
CAP_PVAPI_PIXELFORMAT_MONO8: int
CAP_PVAPI_PIXELFORMAT_RGB24: int
CAP_PVAPI_PIXELFORMAT_RGBA32: int
CAP_QT: int
CAP_REALSENSE: int
CAP_UEYE: int
CAP_UNICAP: int
CAP_V4L: int
CAP_V4L2: int
CAP_VFW: int
CAP_WINRT: int
CAP_XIAPI: int
CAP_XINE: int
CASCADE_DO_CANNY_PRUNING: int
CASCADE_DO_ROUGH_SEARCH: int
CASCADE_FIND_BIGGEST_OBJECT: int
CASCADE_SCALE_IMAGE: int
CCL_BBDT: int
CCL_BOLELLI: int
CCL_DEFAULT: int
CCL_GRANA: int
CCL_SAUF: int
CCL_SPAGHETTI: int
CCL_WU: int
CC_STAT_AREA: int
CC_STAT_HEIGHT: int
CC_STAT_LEFT: int
CC_STAT_MAX: int
CC_STAT_TOP: int
CC_STAT_WIDTH: int
CHAIN_APPROX_NONE: int
CHAIN_APPROX_SIMPLE: int
CHAIN_APPROX_TC89_KCOS: int
CHAIN_APPROX_TC89_L1: int
CMP_EQ: int
CMP_GE: int
CMP_GT: int
CMP_LE: int
CMP_LT: int
CMP_NE: int
COLORMAP_AUTUMN: int
COLORMAP_BONE: int
COLORMAP_CIVIDIS: int
COLORMAP_COOL: int
COLORMAP_DEEPGREEN: int
COLORMAP_HOT: int
COLORMAP_HSV: int
COLORMAP_INFERNO: int
COLORMAP_JET: int
COLORMAP_MAGMA: int
COLORMAP_OCEAN: int
COLORMAP_PARULA: int
COLORMAP_PINK: int
COLORMAP_PLASMA: int
COLORMAP_RAINBOW: int
COLORMAP_SPRING: int
COLORMAP_SUMMER: int
COLORMAP_TURBO: int
COLORMAP_TWILIGHT: int
COLORMAP_TWILIGHT_SHIFTED: int
COLORMAP_VIRIDIS: int
COLORMAP_WINTER: int
COLOR_BGR2BGR555: int
COLOR_BGR2BGR565: int
COLOR_BGR2BGRA: int
COLOR_BGR2GRAY: int
COLOR_BGR2HLS: int
COLOR_BGR2HLS_FULL: int
COLOR_BGR2HSV: int
COLOR_BGR2HSV_FULL: int
COLOR_BGR2Lab: int
COLOR_BGR2Luv: int
COLOR_BGR2RGB: int
COLOR_BGR2RGBA: int
COLOR_BGR2XYZ: int
COLOR_BGR2YCrCb: int
COLOR_BGR2YUV: int
COLOR_BGR2YUV_I420: int
COLOR_BGR2YUV_IYUV: int
COLOR_BGR2YUV_YV12: int
COLOR_BGR5552BGR: int
COLOR_BGR5552BGRA: int
COLOR_BGR5552GRAY: int
COLOR_BGR5552RGB: int
COLOR_BGR5552RGBA: int
COLOR_BGR5652BGR: int
COLOR_BGR5652BGRA: int
COLOR_BGR5652GRAY: int
COLOR_BGR5652RGB: int
COLOR_BGR5652RGBA: int
COLOR_BGRA2BGR: int
COLOR_BGRA2BGR555: int
COLOR_BGRA2BGR565: int
COLOR_BGRA2GRAY: int
COLOR_BGRA2RGB: int
COLOR_BGRA2RGBA: int
COLOR_BGRA2YUV_I420: int
COLOR_BGRA2YUV_IYUV: int
COLOR_BGRA2YUV_YV12: int
COLOR_BayerBG2BGR: int
COLOR_BayerBG2BGRA: int
COLOR_BayerBG2BGR_EA: int
COLOR_BayerBG2BGR_VNG: int
COLOR_BayerBG2GRAY: int
COLOR_BayerBG2RGB: int
COLOR_BayerBG2RGBA: int
COLOR_BayerBG2RGB_EA: int
COLOR_BayerBG2RGB_VNG: int
COLOR_BayerGB2BGR: int
COLOR_BayerGB2BGRA: int
COLOR_BayerGB2BGR_EA: int
COLOR_BayerGB2BGR_VNG: int
COLOR_BayerGB2GRAY: int
COLOR_BayerGB2RGB: int
COLOR_BayerGB2RGBA: int
COLOR_BayerGB2RGB_EA: int
COLOR_BayerGB2RGB_VNG: int
COLOR_BayerGR2BGR: int
COLOR_BayerGR2BGRA: int
COLOR_BayerGR2BGR_EA: int
COLOR_BayerGR2BGR_VNG: int
COLOR_BayerGR2GRAY: int
COLOR_BayerGR2RGB: int
COLOR_BayerGR2RGBA: int
COLOR_BayerGR2RGB_EA: int
COLOR_BayerGR2RGB_VNG: int
COLOR_BayerRG2BGR: int
COLOR_BayerRG2BGRA: int
COLOR_BayerRG2BGR_EA: int
COLOR_BayerRG2BGR_VNG: int
COLOR_BayerRG2GRAY: int
COLOR_BayerRG2RGB: int
COLOR_BayerRG2RGBA: int
COLOR_BayerRG2RGB_EA: int
COLOR_BayerRG2RGB_VNG: int
COLOR_COLORCVT_MAX: int
COLOR_GRAY2BGR: int
COLOR_GRAY2BGR555: int
COLOR_GRAY2BGR565: int
COLOR_GRAY2BGRA: int
COLOR_GRAY2RGB: int
COLOR_GRAY2RGBA: int
COLOR_HLS2BGR: int
COLOR_HLS2BGR_FULL: int
COLOR_HLS2RGB: int
COLOR_HLS2RGB_FULL: int
COLOR_HSV2BGR: int
COLOR_HSV2BGR_FULL: int
COLOR_HSV2RGB: int
COLOR_HSV2RGB_FULL: int
COLOR_LBGR2Lab: int
COLOR_LBGR2Luv: int
COLOR_LRGB2Lab: int
COLOR_LRGB2Luv: int
COLOR_Lab2BGR: int
COLOR_Lab2LBGR: int
COLOR_Lab2LRGB: int
COLOR_Lab2RGB: int
COLOR_Luv2BGR: int
COLOR_Luv2LBGR: int
COLOR_Luv2LRGB: int
COLOR_Luv2RGB: int
COLOR_RGB2BGR: int
COLOR_RGB2BGR555: int
COLOR_RGB2BGR565: int
COLOR_RGB2BGRA: int
COLOR_RGB2GRAY: int
COLOR_RGB2HLS: int
COLOR_RGB2HLS_FULL: int
COLOR_RGB2HSV: int
COLOR_RGB2HSV_FULL: int
COLOR_RGB2Lab: int
COLOR_RGB2Luv: int
COLOR_RGB2RGBA: int
COLOR_RGB2XYZ: int
COLOR_RGB2YCrCb: int
COLOR_RGB2YUV: int
COLOR_RGB2YUV_I420: int
COLOR_RGB2YUV_IYUV: int
COLOR_RGB2YUV_YV12: int
COLOR_RGBA2BGR: int
COLOR_RGBA2BGR555: int
COLOR_RGBA2BGR565: int
COLOR_RGBA2BGRA: int
COLOR_RGBA2GRAY: int
COLOR_RGBA2RGB: int
COLOR_RGBA2YUV_I420: int
COLOR_RGBA2YUV_IYUV: int
COLOR_RGBA2YUV_YV12: int
COLOR_RGBA2mRGBA: int
COLOR_XYZ2BGR: int
COLOR_XYZ2RGB: int
COLOR_YCrCb2BGR: int
COLOR_YCrCb2RGB: int
COLOR_YUV2BGR: int
COLOR_YUV2BGRA_I420: int
COLOR_YUV2BGRA_IYUV: int
COLOR_YUV2BGRA_NV12: int
COLOR_YUV2BGRA_NV21: int
COLOR_YUV2BGRA_UYNV: int
COLOR_YUV2BGRA_UYVY: int
COLOR_YUV2BGRA_Y422: int
COLOR_YUV2BGRA_YUNV: int
COLOR_YUV2BGRA_YUY2: int
COLOR_YUV2BGRA_YUYV: int
COLOR_YUV2BGRA_YV12: int
COLOR_YUV2BGRA_YVYU: int
COLOR_YUV2BGR_I420: int
COLOR_YUV2BGR_IYUV: int
COLOR_YUV2BGR_NV12: int
COLOR_YUV2BGR_NV21: int
COLOR_YUV2BGR_UYNV: int
COLOR_YUV2BGR_UYVY: int
COLOR_YUV2BGR_Y422: int
COLOR_YUV2BGR_YUNV: int
COLOR_YUV2BGR_YUY2: int
COLOR_YUV2BGR_YUYV: int
COLOR_YUV2BGR_YV12: int
COLOR_YUV2BGR_YVYU: int
COLOR_YUV2GRAY_420: int
COLOR_YUV2GRAY_I420: int
COLOR_YUV2GRAY_IYUV: int
COLOR_YUV2GRAY_NV12: int
COLOR_YUV2GRAY_NV21: int
COLOR_YUV2GRAY_UYNV: int
COLOR_YUV2GRAY_UYVY: int
COLOR_YUV2GRAY_Y422: int
COLOR_YUV2GRAY_YUNV: int
COLOR_YUV2GRAY_YUY2: int
COLOR_YUV2GRAY_YUYV: int
COLOR_YUV2GRAY_YV12: int
COLOR_YUV2GRAY_YVYU: int
COLOR_YUV2RGB: int
COLOR_YUV2RGBA_I420: int
COLOR_YUV2RGBA_IYUV: int
COLOR_YUV2RGBA_NV12: int
COLOR_YUV2RGBA_NV21: int
COLOR_YUV2RGBA_UYNV: int
COLOR_YUV2RGBA_UYVY: int
COLOR_YUV2RGBA_Y422: int
COLOR_YUV2RGBA_YUNV: int
COLOR_YUV2RGBA_YUY2: int
COLOR_YUV2RGBA_YUYV: int
COLOR_YUV2RGBA_YV12: int
COLOR_YUV2RGBA_YVYU: int
COLOR_YUV2RGB_I420: int
COLOR_YUV2RGB_IYUV: int
COLOR_YUV2RGB_NV12: int
COLOR_YUV2RGB_NV21: int
COLOR_YUV2RGB_UYNV: int
COLOR_YUV2RGB_UYVY: int
COLOR_YUV2RGB_Y422: int
COLOR_YUV2RGB_YUNV: int
COLOR_YUV2RGB_YUY2: int
COLOR_YUV2RGB_YUYV: int
COLOR_YUV2RGB_YV12: int
COLOR_YUV2RGB_YVYU: int
COLOR_YUV420p2BGR: int
COLOR_YUV420p2BGRA: int
COLOR_YUV420p2GRAY: int
COLOR_YUV420p2RGB: int
COLOR_YUV420p2RGBA: int
COLOR_YUV420sp2BGR: int
COLOR_YUV420sp2BGRA: int
COLOR_YUV420sp2GRAY: int
COLOR_YUV420sp2RGB: int
COLOR_YUV420sp2RGBA: int
COLOR_mRGBA2RGBA: int
CONTOURS_MATCH_I1: int
CONTOURS_MATCH_I2: int
CONTOURS_MATCH_I3: int
COVAR_COLS: int
COVAR_NORMAL: int
COVAR_ROWS: int
COVAR_SCALE: int
COVAR_SCRAMBLED: int
COVAR_USE_AVG: int
CirclesGridFinderParameters_ASYMMETRIC_GRID: int
CirclesGridFinderParameters_SYMMETRIC_GRID: int
DCT_INVERSE: int
DCT_ROWS: int
DECOMP_CHOLESKY: int
DECOMP_EIG: int
DECOMP_LU: int
DECOMP_NORMAL: int
DECOMP_QR: int
DECOMP_SVD: int
DFT_COMPLEX_INPUT: int
DFT_COMPLEX_OUTPUT: int
DFT_INVERSE: int
DFT_REAL_OUTPUT: int
DFT_ROWS: int
DFT_SCALE: int
DISOpticalFlow_PRESET_FAST: int
DISOpticalFlow_PRESET_MEDIUM: int
DISOpticalFlow_PRESET_ULTRAFAST: int
DIST_C: int
DIST_FAIR: int
DIST_HUBER: int
DIST_L1: int
DIST_L12: int
DIST_L2: int
DIST_LABEL_CCOMP: int
DIST_LABEL_PIXEL: int
DIST_MASK_3: int
DIST_MASK_5: int
DIST_MASK_PRECISE: int
DIST_USER: int
DIST_WELSCH: int
DescriptorMatcher_BRUTEFORCE: int
DescriptorMatcher_BRUTEFORCE_HAMMING: int
DescriptorMatcher_BRUTEFORCE_HAMMINGLUT: int
DescriptorMatcher_BRUTEFORCE_L1: int
DescriptorMatcher_BRUTEFORCE_SL2: int
DescriptorMatcher_FLANNBASED: int
DrawMatchesFlags_DEFAULT: int
DrawMatchesFlags_DRAW_OVER_OUTIMG: int
DrawMatchesFlags_DRAW_RICH_KEYPOINTS: int
DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS: int
EVENT_FLAG_ALTKEY: int
EVENT_FLAG_CTRLKEY: int
EVENT_FLAG_LBUTTON: int
EVENT_FLAG_MBUTTON: int
EVENT_FLAG_RBUTTON: int
EVENT_FLAG_SHIFTKEY: int
EVENT_LBUTTONDBLCLK: int
EVENT_LBUTTONDOWN: int
EVENT_LBUTTONUP: int
EVENT_MBUTTONDBLCLK: int
EVENT_MBUTTONDOWN: int
EVENT_MBUTTONUP: int
EVENT_MOUSEHWHEEL: int
EVENT_MOUSEMOVE: int
EVENT_MOUSEWHEEL: int
EVENT_RBUTTONDBLCLK: int
EVENT_RBUTTONDOWN: int
EVENT_RBUTTONUP: int
FILLED: int
FILTER_SCHARR: int
FLOODFILL_FIXED_RANGE: int
FLOODFILL_MASK_ONLY: int
FM_7POINT: int
FM_8POINT: int
FM_LMEDS: int
FM_RANSAC: int
FONT_HERSHEY_COMPLEX: int
FONT_HERSHEY_COMPLEX_SMALL: int
FONT_HERSHEY_DUPLEX: int
FONT_HERSHEY_PLAIN: int
FONT_HERSHEY_SCRIPT_COMPLEX: int
FONT_HERSHEY_SCRIPT_SIMPLEX: int
FONT_HERSHEY_SIMPLEX: int
FONT_HERSHEY_TRIPLEX: int
FONT_ITALIC: int
FastFeatureDetector_FAST_N: int
FastFeatureDetector_NONMAX_SUPPRESSION: int
FastFeatureDetector_THRESHOLD: int
FastFeatureDetector_TYPE_5_8: int
FastFeatureDetector_TYPE_7_12: int
FastFeatureDetector_TYPE_9_16: int
FileNode_EMPTY: int
FileNode_FLOAT: int
FileNode_FLOW: int
FileNode_INT: int
FileNode_MAP: int
FileNode_NAMED: int
FileNode_NONE: int
FileNode_REAL: int
FileNode_SEQ: int
FileNode_STR: int
FileNode_STRING: int
FileNode_TYPE_MASK: int
FileNode_UNIFORM: int
FileStorage_APPEND: int
FileStorage_BASE64: int
FileStorage_FORMAT_AUTO: int
FileStorage_FORMAT_JSON: int
FileStorage_FORMAT_MASK: int
FileStorage_FORMAT_XML: int
FileStorage_FORMAT_YAML: int
FileStorage_INSIDE_MAP: int
FileStorage_MEMORY: int
FileStorage_NAME_EXPECTED: int
FileStorage_READ: int
FileStorage_UNDEFINED: int
FileStorage_VALUE_EXPECTED: int
FileStorage_WRITE: int
FileStorage_WRITE_BASE64: int
Formatter_FMT_C: int
Formatter_FMT_CSV: int
Formatter_FMT_DEFAULT: int
Formatter_FMT_MATLAB: int
Formatter_FMT_NUMPY: int
Formatter_FMT_PYTHON: int
GC_BGD: int
GC_EVAL: int
GC_EVAL_FREEZE_MODEL: int
GC_FGD: int
GC_INIT_WITH_MASK: int
GC_INIT_WITH_RECT: int
GC_PR_BGD: int
GC_PR_FGD: int
GEMM_1_T: int
GEMM_2_T: int
GEMM_3_T: int
GFluidKernel_Kind_Filter: int
GFluidKernel_Kind_Resize: int
GFluidKernel_Kind_YUV420toRGB: int
GShape_GARRAY: int
GShape_GFRAME: int
GShape_GMAT: int
GShape_GOPAQUE: int
GShape_GSCALAR: int
HISTCMP_BHATTACHARYYA: int
HISTCMP_CHISQR: int
HISTCMP_CHISQR_ALT: int
HISTCMP_CORREL: int
HISTCMP_HELLINGER: int
HISTCMP_INTERSECT: int
HISTCMP_KL_DIV: int
HOGDescriptor_DEFAULT_NLEVELS: int
HOGDescriptor_DESCR_FORMAT_COL_BY_COL: int
HOGDescriptor_DESCR_FORMAT_ROW_BY_ROW: int
HOGDescriptor_L2Hys: int
HOUGH_GRADIENT: int
HOUGH_GRADIENT_ALT: int
HOUGH_MULTI_SCALE: int
HOUGH_PROBABILISTIC: int
HOUGH_STANDARD: int
IMREAD_ANYCOLOR: int
IMREAD_ANYDEPTH: int
IMREAD_COLOR: int
IMREAD_GRAYSCALE: int
IMREAD_IGNORE_ORIENTATION: int
IMREAD_LOAD_GDAL: int
IMREAD_REDUCED_COLOR_2: int
IMREAD_REDUCED_COLOR_4: int
IMREAD_REDUCED_COLOR_8: int
IMREAD_REDUCED_GRAYSCALE_2: int
IMREAD_REDUCED_GRAYSCALE_4: int
IMREAD_REDUCED_GRAYSCALE_8: int
IMREAD_UNCHANGED: int
IMWRITE_EXR_COMPRESSION: int
IMWRITE_EXR_COMPRESSION_B44: int
IMWRITE_EXR_COMPRESSION_B44A: int
IMWRITE_EXR_COMPRESSION_DWAA: int
IMWRITE_EXR_COMPRESSION_DWAB: int
IMWRITE_EXR_COMPRESSION_NO: int
IMWRITE_EXR_COMPRESSION_PIZ: int
IMWRITE_EXR_COMPRESSION_PXR24: int
IMWRITE_EXR_COMPRESSION_RLE: int
IMWRITE_EXR_COMPRESSION_ZIP: int
IMWRITE_EXR_COMPRESSION_ZIPS: int
IMWRITE_EXR_TYPE: int
IMWRITE_EXR_TYPE_FLOAT: int
IMWRITE_EXR_TYPE_HALF: int
IMWRITE_JPEG2000_COMPRESSION_X1000: int
IMWRITE_JPEG_CHROMA_QUALITY: int
IMWRITE_JPEG_LUMA_QUALITY: int
IMWRITE_JPEG_OPTIMIZE: int
IMWRITE_JPEG_PROGRESSIVE: int
IMWRITE_JPEG_QUALITY: int
IMWRITE_JPEG_RST_INTERVAL: int
IMWRITE_PAM_FORMAT_BLACKANDWHITE: int
IMWRITE_PAM_FORMAT_GRAYSCALE: int
IMWRITE_PAM_FORMAT_GRAYSCALE_ALPHA: int
IMWRITE_PAM_FORMAT_NULL: int
IMWRITE_PAM_FORMAT_RGB: int
IMWRITE_PAM_FORMAT_RGB_ALPHA: int
IMWRITE_PAM_TUPLETYPE: int
IMWRITE_PNG_BILEVEL: int
IMWRITE_PNG_COMPRESSION: int
IMWRITE_PNG_STRATEGY: int
IMWRITE_PNG_STRATEGY_DEFAULT: int
IMWRITE_PNG_STRATEGY_FILTERED: int
IMWRITE_PNG_STRATEGY_FIXED: int
IMWRITE_PNG_STRATEGY_HUFFMAN_ONLY: int
IMWRITE_PNG_STRATEGY_RLE: int
IMWRITE_PXM_BINARY: int
IMWRITE_TIFF_COMPRESSION: int
IMWRITE_TIFF_RESUNIT: int
IMWRITE_TIFF_XDPI: int
IMWRITE_TIFF_YDPI: int
IMWRITE_WEBP_QUALITY: int
INPAINT_NS: int
INPAINT_TELEA: int
INTERSECT_FULL: int
INTERSECT_NONE: int
INTERSECT_PARTIAL: int
INTER_AREA: int
INTER_BITS: int
INTER_BITS2: int
INTER_CUBIC: int
INTER_LANCZOS4: int
INTER_LINEAR: int
INTER_LINEAR_EXACT: int
INTER_MAX: int
INTER_NEAREST: int
INTER_NEAREST_EXACT: int
INTER_TAB_SIZE: int
INTER_TAB_SIZE2: int
KAZE_DIFF_CHARBONNIER: int
KAZE_DIFF_PM_G1: int
KAZE_DIFF_PM_G2: int
KAZE_DIFF_WEICKERT: int
KMEANS_PP_CENTERS: int
KMEANS_RANDOM_CENTERS: int
KMEANS_USE_INITIAL_LABELS: int
LDR_SIZE: int
LINE_4: int
LINE_8: int
LINE_AA: int
LMEDS: int
LOCAL_OPTIM_GC: int
LOCAL_OPTIM_INNER_AND_ITER_LO: int
LOCAL_OPTIM_INNER_LO: int
LOCAL_OPTIM_NULL: int
LOCAL_OPTIM_SIGMA: int
MARKER_CROSS: int
MARKER_DIAMOND: int
MARKER_SQUARE: int
MARKER_STAR: int
MARKER_TILTED_CROSS: int
MARKER_TRIANGLE_DOWN: int
MARKER_TRIANGLE_UP: int
MIXED_CLONE: int
MONOCHROME_TRANSFER: int
MORPH_BLACKHAT: int
MORPH_CLOSE: int
MORPH_CROSS: int
MORPH_DILATE: int
MORPH_ELLIPSE: int
MORPH_ERODE: int
MORPH_GRADIENT: int
MORPH_HITMISS: int
MORPH_OPEN: int
MORPH_RECT: int
MORPH_TOPHAT: int
MOTION_AFFINE: int
MOTION_EUCLIDEAN: int
MOTION_HOMOGRAPHY: int
MOTION_TRANSLATION: int
Mat_AUTO_STEP: int
Mat_CONTINUOUS_FLAG: int
Mat_DEPTH_MASK: int
Mat_MAGIC_MASK: int
Mat_MAGIC_VAL: int
Mat_SUBMATRIX_FLAG: int
Mat_TYPE_MASK: int
MediaFormat_BGR: int
MediaFormat_NV12: int
MediaFrame_Access_R: int
MediaFrame_Access_W: int
NEIGH_FLANN_KNN: int
NEIGH_FLANN_RADIUS: int
NEIGH_GRID: int
NORMAL_CLONE: int
NORMCONV_FILTER: int
NORM_HAMMING: int
NORM_HAMMING2: int
NORM_INF: int
NORM_L1: int
NORM_L2: int
NORM_L2SQR: int
NORM_MINMAX: int
NORM_RELATIVE: int
NORM_TYPE_MASK: int
OPTFLOW_FARNEBACK_GAUSSIAN: int
OPTFLOW_LK_GET_MIN_EIGENVALS: int
OPTFLOW_USE_INITIAL_FLOW: int
ORB_FAST_SCORE: int
ORB_HARRIS_SCORE: int
PCA_DATA_AS_COL: int
PCA_DATA_AS_ROW: int
PCA_USE_AVG: int
PROJ_SPHERICAL_EQRECT: int
PROJ_SPHERICAL_ORTHO: int
PUT_TEXT_ALIGN_CENTER: int
PUT_TEXT_ALIGN_LEFT: int
PUT_TEXT_ALIGN_MASK: int
PUT_TEXT_ALIGN_RIGHT: int
PUT_TEXT_ORIGIN_BL: int
PUT_TEXT_ORIGIN_TL: int
PUT_TEXT_WRAP: int
Param_ALGORITHM: int
Param_BOOLEAN: int
Param_FLOAT: int
Param_INT: int
Param_MAT: int
Param_MAT_VECTOR: int
Param_REAL: int
Param_SCALAR: int
Param_STRING: int
Param_UCHAR: int
Param_UINT64: int
Param_UNSIGNED_INT: int
QT_CHECKBOX: int
QT_FONT_BLACK: int
QT_FONT_BOLD: int
QT_FONT_DEMIBOLD: int
QT_FONT_LIGHT: int
QT_FONT_NORMAL: int
QT_NEW_BUTTONBAR: int
QT_PUSH_BUTTON: int
QT_RADIOBOX: int
QT_STYLE_ITALIC: int
QT_STYLE_NORMAL: int
QT_STYLE_OBLIQUE: int
QUAT_ASSUME_NOT_UNIT: int
QUAT_ASSUME_UNIT: int
QuatEnum_EULER_ANGLES_MAX_VALUE: int
QuatEnum_EXT_XYX: int
QuatEnum_EXT_XYZ: int
QuatEnum_EXT_XZX: int
QuatEnum_EXT_XZY: int
QuatEnum_EXT_YXY: int
QuatEnum_EXT_YXZ: int
QuatEnum_EXT_YZX: int
QuatEnum_EXT_YZY: int
QuatEnum_EXT_ZXY: int
QuatEnum_EXT_ZXZ: int
QuatEnum_EXT_ZYX: int
QuatEnum_EXT_ZYZ: int
QuatEnum_INT_XYX: int
QuatEnum_INT_XYZ: int
QuatEnum_INT_XZX: int
QuatEnum_INT_XZY: int
QuatEnum_INT_YXY: int
QuatEnum_INT_YXZ: int
QuatEnum_INT_YZX: int
QuatEnum_INT_YZY: int
QuatEnum_INT_ZXY: int
QuatEnum_INT_ZXZ: int
QuatEnum_INT_ZYX: int
QuatEnum_INT_ZYZ: int
RANSAC: int
RECURS_FILTER: int
REDUCE_AVG: int
REDUCE_MAX: int
REDUCE_MIN: int
REDUCE_SUM: int
RETR_CCOMP: int
RETR_EXTERNAL: int
RETR_FLOODFILL: int
RETR_LIST: int
RETR_TREE: int
RHO: int
RMat_Access_R: int
RMat_Access_W: int
RNG_NORMAL: int
RNG_UNIFORM: int
ROTATE_180: int
ROTATE_90_CLOCKWISE: int
ROTATE_90_COUNTERCLOCKWISE: int
SAMPLING_NAPSAC: int
SAMPLING_PROGRESSIVE_NAPSAC: int
SAMPLING_PROSAC: int
SAMPLING_UNIFORM: int
SCORE_METHOD_LMEDS: int
SCORE_METHOD_MAGSAC: int
SCORE_METHOD_MSAC: int
SCORE_METHOD_RANSAC: int
SOLVELP_MULTI: int
SOLVELP_SINGLE: int
SOLVELP_UNBOUNDED: int
SOLVELP_UNFEASIBLE: int
SOLVEPNP_AP3P: int
SOLVEPNP_DLS: int
SOLVEPNP_EPNP: int
SOLVEPNP_IPPE: int
SOLVEPNP_IPPE_SQUARE: int
SOLVEPNP_ITERATIVE: int
SOLVEPNP_MAX_COUNT: int
SOLVEPNP_P3P: int
SOLVEPNP_SQPNP: int
SOLVEPNP_UPNP: int
SORT_ASCENDING: int
SORT_DESCENDING: int
SORT_EVERY_COLUMN: int
SORT_EVERY_ROW: int
STEREO_ZERO_DISPARITY: int
SVD_FULL_UV: int
SVD_MODIFY_A: int
SVD_NO_UV: int
SparseMat_HASH_BIT: int
SparseMat_HASH_SCALE: int
SparseMat_MAGIC_VAL: int
SparseMat_MAX_DIM: int
StereoBM_PREFILTER_NORMALIZED_RESPONSE: int
StereoBM_PREFILTER_XSOBEL: int
StereoMatcher_DISP_SCALE: int
StereoMatcher_DISP_SHIFT: int
StereoSGBM_MODE_HH: int
StereoSGBM_MODE_HH4: int
StereoSGBM_MODE_SGBM: int
StereoSGBM_MODE_SGBM_3WAY: int
Stitcher_ERR_CAMERA_PARAMS_ADJUST_FAIL: int
Stitcher_ERR_HOMOGRAPHY_EST_FAIL: int
Stitcher_ERR_NEED_MORE_IMGS: int
Stitcher_OK: int
Stitcher_PANORAMA: int
Stitcher_SCANS: int
Subdiv2D_NEXT_AROUND_DST: int
Subdiv2D_NEXT_AROUND_LEFT: int
Subdiv2D_NEXT_AROUND_ORG: int
Subdiv2D_NEXT_AROUND_RIGHT: int
Subdiv2D_PREV_AROUND_DST: int
Subdiv2D_PREV_AROUND_LEFT: int
Subdiv2D_PREV_AROUND_ORG: int
Subdiv2D_PREV_AROUND_RIGHT: int
Subdiv2D_PTLOC_ERROR: int
Subdiv2D_PTLOC_INSIDE: int
Subdiv2D_PTLOC_ON_EDGE: int
Subdiv2D_PTLOC_OUTSIDE_RECT: int
Subdiv2D_PTLOC_VERTEX: int
THRESH_BINARY: int
THRESH_BINARY_INV: int
THRESH_MASK: int
THRESH_OTSU: int
THRESH_TOZERO: int
THRESH_TOZERO_INV: int
THRESH_TRIANGLE: int
THRESH_TRUNC: int
TM_CCOEFF: int
TM_CCOEFF_NORMED: int
TM_CCORR: int
TM_CCORR_NORMED: int
TM_SQDIFF: int
TM_SQDIFF_NORMED: int
TermCriteria_COUNT: int
TermCriteria_EPS: int
TermCriteria_MAX_ITER: int
UMatData_ASYNC_CLEANUP: int
UMatData_COPY_ON_MAP: int
UMatData_DEVICE_COPY_OBSOLETE: int
UMatData_DEVICE_MEM_MAPPED: int
UMatData_HOST_COPY_OBSOLETE: int
UMatData_TEMP_COPIED_UMAT: int
UMatData_TEMP_UMAT: int
UMatData_USER_ALLOCATED: int
UMat_AUTO_STEP: int
UMat_CONTINUOUS_FLAG: int
UMat_DEPTH_MASK: int
UMat_MAGIC_MASK: int
UMat_MAGIC_VAL: int
UMat_SUBMATRIX_FLAG: int
UMat_TYPE_MASK: int
USAC_ACCURATE: int
USAC_DEFAULT: int
USAC_FAST: int
USAC_FM_8PTS: int
USAC_MAGSAC: int
USAC_PARALLEL: int
USAC_PROSAC: int
USAGE_ALLOCATE_DEVICE_MEMORY: int
USAGE_ALLOCATE_HOST_MEMORY: int
USAGE_ALLOCATE_SHARED_MEMORY: int
USAGE_DEFAULT: int
VIDEOWRITER_PROP_DEPTH: int
VIDEOWRITER_PROP_FRAMEBYTES: int
VIDEOWRITER_PROP_HW_ACCELERATION: int
VIDEOWRITER_PROP_HW_ACCELERATION_USE_OPENCL: int
VIDEOWRITER_PROP_HW_DEVICE: int
VIDEOWRITER_PROP_IS_COLOR: int
VIDEOWRITER_PROP_NSTRIPES: int
VIDEOWRITER_PROP_QUALITY: int
VIDEO_ACCELERATION_ANY: int
VIDEO_ACCELERATION_D3D11: int
VIDEO_ACCELERATION_MFX: int
VIDEO_ACCELERATION_NONE: int
VIDEO_ACCELERATION_VAAPI: int
WARP_FILL_OUTLIERS: int
WARP_INVERSE_MAP: int
WARP_POLAR_LINEAR: int
WARP_POLAR_LOG: int
WINDOW_AUTOSIZE: int
WINDOW_FREERATIO: int
WINDOW_FULLSCREEN: int
WINDOW_GUI_EXPANDED: int
WINDOW_GUI_NORMAL: int
WINDOW_KEEPRATIO: int
WINDOW_NORMAL: int
WINDOW_OPENGL: int
WND_PROP_ASPECT_RATIO: int
WND_PROP_AUTOSIZE: int
WND_PROP_FULLSCREEN: int
WND_PROP_OPENGL: int
WND_PROP_TOPMOST: int
WND_PROP_VISIBLE: int
WND_PROP_VSYNC: int
_InputArray_CUDA_GPU_MAT: int
_InputArray_CUDA_HOST_MEM: int
_InputArray_EXPR: int
_InputArray_FIXED_SIZE: int
_InputArray_FIXED_TYPE: int
_InputArray_KIND_MASK: int
_InputArray_KIND_SHIFT: int
_InputArray_MAT: int
_InputArray_MATX: int
_InputArray_NONE: int
_InputArray_OPENGL_BUFFER: int
_InputArray_STD_ARRAY: int
_InputArray_STD_ARRAY_MAT: int
_InputArray_STD_BOOL_VECTOR: int
_InputArray_STD_VECTOR: int
_InputArray_STD_VECTOR_CUDA_GPU_MAT: int
_InputArray_STD_VECTOR_MAT: int
_InputArray_STD_VECTOR_UMAT: int
_InputArray_STD_VECTOR_VECTOR: int
_InputArray_UMAT: int
_OutputArray_DEPTH_MASK_16F: int
_OutputArray_DEPTH_MASK_16S: int
_OutputArray_DEPTH_MASK_16U: int
_OutputArray_DEPTH_MASK_32F: int
_OutputArray_DEPTH_MASK_32S: int
_OutputArray_DEPTH_MASK_64F: int
_OutputArray_DEPTH_MASK_8S: int
_OutputArray_DEPTH_MASK_8U: int
_OutputArray_DEPTH_MASK_ALL: int
_OutputArray_DEPTH_MASK_ALL_16F: int
_OutputArray_DEPTH_MASK_ALL_BUT_8S: int
_OutputArray_DEPTH_MASK_FLT: int
__UMAT_USAGE_FLAGS_32BIT: int

# cv.gapi.onnx
TraitAs_IMAGE: int
TraitAs_TENSOR: int

# cv.parallel

# cv.utils.fs

# cv.gapi.ie.detail
ParamDesc_Kind_Import: int
ParamDesc_Kind_Load: int

# cv.videoio_registry

# cv.cuda
DYNAMIC_PARALLELISM: int
DeviceInfo_ComputeModeDefault: int
DeviceInfo_ComputeModeExclusive: int
DeviceInfo_ComputeModeExclusiveProcess: int
DeviceInfo_ComputeModeProhibited: int
Event_BLOCKING_SYNC: int
Event_DEFAULT: int
Event_DISABLE_TIMING: int
Event_INTERPROCESS: int
FEATURE_SET_COMPUTE_10: int
FEATURE_SET_COMPUTE_11: int
FEATURE_SET_COMPUTE_12: int
FEATURE_SET_COMPUTE_13: int
FEATURE_SET_COMPUTE_20: int
FEATURE_SET_COMPUTE_21: int
FEATURE_SET_COMPUTE_30: int
FEATURE_SET_COMPUTE_32: int
FEATURE_SET_COMPUTE_35: int
FEATURE_SET_COMPUTE_50: int
GLOBAL_ATOMICS: int
HostMem_PAGE_LOCKED: int
HostMem_SHARED: int
HostMem_WRITE_COMBINED: int
NATIVE_DOUBLE: int
SHARED_ATOMICS: int
WARP_SHUFFLE_FUNCTIONS: int

# cv.gapi
CV_ANY: int
CV_BOOL: int
CV_DOUBLE: int
CV_FLOAT: int
CV_GMAT: int
CV_INT: int
CV_MAT: int
CV_POINT: int
CV_POINT2F: int
CV_RECT: int
CV_SCALAR: int
CV_SIZE: int
CV_STRING: int
StereoOutputFormat_DEPTH_16F: int
StereoOutputFormat_DEPTH_32F: int
StereoOutputFormat_DEPTH_FLOAT16: int
StereoOutputFormat_DEPTH_FLOAT32: int
StereoOutputFormat_DISPARITY_16Q_10_5: int
StereoOutputFormat_DISPARITY_16Q_11_4: int
StereoOutputFormat_DISPARITY_FIXED16_11_5: int
StereoOutputFormat_DISPARITY_FIXED16_12_4: int

# cv.ipp

# cv.gapi.streaming
sync_policy_dont_sync: int
sync_policy_drop: int

# cv.fisheye
CALIB_CHECK_COND: int
CALIB_FIX_FOCAL_LENGTH: int
CALIB_FIX_INTRINSIC: int
CALIB_FIX_K1: int
CALIB_FIX_K2: int
CALIB_FIX_K3: int
CALIB_FIX_K4: int
CALIB_FIX_PRINCIPAL_POINT: int
CALIB_FIX_SKEW: int
CALIB_RECOMPUTE_EXTRINSIC: int
CALIB_USE_INTRINSIC_GUESS: int
CALIB_ZERO_DISPARITY: int

# cv.segmentation

# cv.ogl
Buffer_ARRAY_BUFFER: int
Buffer_ELEMENT_ARRAY_BUFFER: int
Buffer_PIXEL_PACK_BUFFER: int
Buffer_PIXEL_UNPACK_BUFFER: int
Buffer_READ_ONLY: int
Buffer_READ_WRITE: int
Buffer_WRITE_ONLY: int
LINES: int
LINE_LOOP: int
LINE_STRIP: int
POINTS: int
POLYGON: int
QUADS: int
QUAD_STRIP: int
TRIANGLES: int
TRIANGLE_FAN: int
TRIANGLE_STRIP: int
Texture2D_DEPTH_COMPONENT: int
Texture2D_NONE: int
Texture2D_RGB: int
Texture2D_RGBA: int

# cv.dnn
DNN_BACKEND_CUDA: int
DNN_BACKEND_DEFAULT: int
DNN_BACKEND_HALIDE: int
DNN_BACKEND_INFERENCE_ENGINE: int
DNN_BACKEND_OPENCV: int
DNN_BACKEND_VKCOM: int
DNN_TARGET_CPU: int
DNN_TARGET_CUDA: int
DNN_TARGET_CUDA_FP16: int
DNN_TARGET_FPGA: int
DNN_TARGET_HDDL: int
DNN_TARGET_MYRIAD: int
DNN_TARGET_OPENCL: int
DNN_TARGET_OPENCL_FP16: int
DNN_TARGET_VULKAN: int

# cv.gapi.core.cpu

# cv.ocl
Device_EXEC_KERNEL: int
Device_EXEC_NATIVE_KERNEL: int
Device_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT: int
Device_FP_DENORM: int
Device_FP_FMA: int
Device_FP_INF_NAN: int
Device_FP_ROUND_TO_INF: int
Device_FP_ROUND_TO_NEAREST: int
Device_FP_ROUND_TO_ZERO: int
Device_FP_SOFT_FLOAT: int
Device_LOCAL_IS_GLOBAL: int
Device_LOCAL_IS_LOCAL: int
Device_NO_CACHE: int
Device_NO_LOCAL_MEM: int
Device_READ_ONLY_CACHE: int
Device_READ_WRITE_CACHE: int
Device_TYPE_ACCELERATOR: int
Device_TYPE_ALL: int
Device_TYPE_CPU: int
Device_TYPE_DEFAULT: int
Device_TYPE_DGPU: int
Device_TYPE_GPU: int
Device_TYPE_IGPU: int
Device_UNKNOWN_VENDOR: int
Device_VENDOR_AMD: int
Device_VENDOR_INTEL: int
Device_VENDOR_NVIDIA: int
KernelArg_CONSTANT: int
KernelArg_LOCAL: int
KernelArg_NO_SIZE: int
KernelArg_PTR_ONLY: int
KernelArg_READ_ONLY: int
KernelArg_READ_WRITE: int
KernelArg_WRITE_ONLY: int
OCL_VECTOR_DEFAULT: int
OCL_VECTOR_MAX: int
OCL_VECTOR_OWN: int

# cv.gapi.own.detail
MatHeader_AUTO_STEP: int
MatHeader_TYPE_MASK: int

# cv.flann
FLANN_INDEX_TYPE_16S: int
FLANN_INDEX_TYPE_16U: int
FLANN_INDEX_TYPE_32F: int
FLANN_INDEX_TYPE_32S: int
FLANN_INDEX_TYPE_64F: int
FLANN_INDEX_TYPE_8S: int
FLANN_INDEX_TYPE_8U: int
FLANN_INDEX_TYPE_ALGORITHM: int
FLANN_INDEX_TYPE_BOOL: int
FLANN_INDEX_TYPE_STRING: int
LAST_VALUE_FLANN_INDEX_TYPE: int

# cv.gapi.wip

# cv.detail
ArgKind_GARRAY: int
ArgKind_GFRAME: int
ArgKind_GMAT: int
ArgKind_GMATP: int
ArgKind_GOBJREF: int
ArgKind_GOPAQUE: int
ArgKind_GSCALAR: int
ArgKind_OPAQUE: int
ArgKind_OPAQUE_VAL: int
Blender_FEATHER: int
Blender_MULTI_BAND: int
Blender_NO: int
DpSeamFinder_COLOR: int
DpSeamFinder_COLOR_GRAD: int
ExposureCompensator_CHANNELS: int
ExposureCompensator_CHANNELS_BLOCKS: int
ExposureCompensator_GAIN: int
ExposureCompensator_GAIN_BLOCKS: int
ExposureCompensator_NO: int
GraphCutSeamFinderBase_COST_COLOR: int
GraphCutSeamFinderBase_COST_COLOR_GRAD: int
OpaqueKind_CV_BOOL: int
OpaqueKind_CV_DOUBLE: int
OpaqueKind_CV_DRAW_PRIM: int
OpaqueKind_CV_FLOAT: int
OpaqueKind_CV_INT: int
OpaqueKind_CV_MAT: int
OpaqueKind_CV_POINT: int
OpaqueKind_CV_POINT2F: int
OpaqueKind_CV_RECT: int
OpaqueKind_CV_SCALAR: int
OpaqueKind_CV_SIZE: int
OpaqueKind_CV_STRING: int
OpaqueKind_CV_UINT64: int
OpaqueKind_CV_UNKNOWN: int
SeamFinder_DP_SEAM: int
SeamFinder_NO: int
SeamFinder_VORONOI_SEAM: int
TEST_CUSTOM: int
TEST_EQ: int
TEST_GE: int
TEST_GT: int
TEST_LE: int
TEST_LT: int
TEST_NE: int
Timelapser_AS_IS: int
Timelapser_CROP: int
TrackerSamplerCSC_MODE_DETECT: int
TrackerSamplerCSC_MODE_INIT_NEG: int
TrackerSamplerCSC_MODE_INIT_POS: int
TrackerSamplerCSC_MODE_TRACK_NEG: int
TrackerSamplerCSC_MODE_TRACK_POS: int
WAVE_CORRECT_AUTO: int
WAVE_CORRECT_HORIZ: int
WAVE_CORRECT_VERT: int

# cv.ml
ANN_MLP_ANNEAL: int
ANN_MLP_BACKPROP: int
ANN_MLP_GAUSSIAN: int
ANN_MLP_IDENTITY: int
ANN_MLP_LEAKYRELU: int
ANN_MLP_NO_INPUT_SCALE: int
ANN_MLP_NO_OUTPUT_SCALE: int
ANN_MLP_RELU: int
ANN_MLP_RPROP: int
ANN_MLP_SIGMOID_SYM: int
ANN_MLP_UPDATE_WEIGHTS: int
Boost_DISCRETE: int
Boost_GENTLE: int
Boost_LOGIT: int
Boost_REAL: int
COL_SAMPLE: int
DTrees_PREDICT_AUTO: int
DTrees_PREDICT_MASK: int
DTrees_PREDICT_MAX_VOTE: int
DTrees_PREDICT_SUM: int
EM_COV_MAT_DEFAULT: int
EM_COV_MAT_DIAGONAL: int
EM_COV_MAT_GENERIC: int
EM_COV_MAT_SPHERICAL: int
EM_DEFAULT_MAX_ITERS: int
EM_DEFAULT_NCLUSTERS: int
EM_START_AUTO_STEP: int
EM_START_E_STEP: int
EM_START_M_STEP: int
KNearest_BRUTE_FORCE: int
KNearest_KDTREE: int
LogisticRegression_BATCH: int
LogisticRegression_MINI_BATCH: int
LogisticRegression_REG_DISABLE: int
LogisticRegression_REG_L1: int
LogisticRegression_REG_L2: int
ROW_SAMPLE: int
SVMSGD_ASGD: int
SVMSGD_HARD_MARGIN: int
SVMSGD_SGD: int
SVMSGD_SOFT_MARGIN: int
SVM_C: int
SVM_CHI2: int
SVM_COEF: int
SVM_CUSTOM: int
SVM_C_SVC: int
SVM_DEGREE: int
SVM_EPS_SVR: int
SVM_GAMMA: int
SVM_INTER: int
SVM_LINEAR: int
SVM_NU: int
SVM_NU_SVC: int
SVM_NU_SVR: int
SVM_ONE_CLASS: int
SVM_P: int
SVM_POLY: int
SVM_RBF: int
SVM_SIGMOID: int
StatModel_COMPRESSED_INPUT: int
StatModel_PREPROCESSED_INPUT: int
StatModel_RAW_OUTPUT: int
StatModel_UPDATE_MODEL: int
TEST_ERROR: int
TRAIN_ERROR: int
VAR_CATEGORICAL: int
VAR_NUMERICAL: int
VAR_ORDERED: int

# cv.Error
BadAlign: int
BadAlphaChannel: int
BadCOI: int
BadCallBack: int
BadDataPtr: int
BadDepth: int
BadImageSize: int
BadModelOrChSeq: int
BadNumChannel1U: int
BadNumChannels: int
BadOffset: int
BadOrder: int
BadOrigin: int
BadROISize: int
BadStep: int
BadTileSize: int
GpuApiCallError: int
GpuNotSupported: int
HeaderIsNull: int
MaskIsTiled: int
OpenCLApiCallError: int
OpenCLDoubleNotSupported: int
OpenCLInitError: int
OpenCLNoAMDBlasFft: int
OpenGlApiCallError: int
OpenGlNotSupported: int
StsAssert: int
StsAutoTrace: int
StsBackTrace: int
StsBadArg: int
StsBadFlag: int
StsBadFunc: int
StsBadMask: int
StsBadMemBlock: int
StsBadPoint: int
StsBadSize: int
StsDivByZero: int
StsError: int
StsFilterOffsetErr: int
StsFilterStructContentErr: int
StsInplaceNotSupported: int
StsInternal: int
StsKernelStructContentErr: int
StsNoConv: int
StsNoMem: int
StsNotImplemented: int
StsNullPtr: int
StsObjectNotFound: int
StsOk: int
StsOutOfRange: int
StsParseError: int
StsUnmatchedFormats: int
StsUnmatchedSizes: int
StsUnsupportedFormat: int
StsVecLengthErr: int

# cv.samples

class AKAZE:
    @staticmethod
    def create(descriptor_type: AKAZE_DescriptorType = ..., descriptor_size: int = ..., descriptor_channels: int = ..., threshold: float = ..., nOctaves: int = ..., nOctaveLayers: int = ..., diffusivity: KAZE_DiffusivityType = ...) -> AKAZE: ...
    def getDefaultName(self) -> str: ...
    def getDescriptorChannels(self) -> int: ...
    def getDescriptorSize(self) -> int: ...
    def getDescriptorType(self) -> AKAZE_DescriptorType: ...
    def getDiffusivity(self) -> KAZE_DiffusivityType: ...
    def getNOctaveLayers(self) -> int: ...
    def getNOctaves(self) -> int: ...
    def getThreshold(self) -> float: ...
    def setDescriptorChannels(self, dch: int) -> None: ...
    def setDescriptorSize(self, dsize: int) -> None: ...
    def setDescriptorType(self, dtype: AKAZE_DescriptorType) -> None: ...
    def setDiffusivity(self, diff: KAZE_DiffusivityType) -> None: ...
    def setNOctaveLayers(self, octaveLayers: int) -> None: ...
    def setNOctaves(self, octaves: int) -> None: ...
    def setThreshold(self, threshold: float) -> None: ...


class AffineFeature:
    @staticmethod
    def create(backend: Feature2D, maxTilt: int = ..., minTilt: int = ..., tiltStep: float = ..., rotateStepBase: float = ...) -> AffineFeature: ...
    def getDefaultName(self) -> str: ...
    def getViewParams(self, tilts: Sequence[float], rolls: Sequence[float]) -> None: ...
    def setViewParams(self, tilts: Sequence[float], rolls: Sequence[float]) -> None: ...


class AgastFeatureDetector:
    @staticmethod
    def create(threshold: int = ..., nonmaxSuppression: bool = ..., type: AgastFeatureDetector_DetectorType = ...) -> AgastFeatureDetector: ...
    def getDefaultName(self) -> str: ...
    def getNonmaxSuppression(self) -> bool: ...
    def getThreshold(self) -> int: ...
    def getType(self) -> AgastFeatureDetector_DetectorType: ...
    def setNonmaxSuppression(self, f: bool) -> None: ...
    def setThreshold(self, threshold: int) -> None: ...
    def setType(self, type: AgastFeatureDetector_DetectorType) -> None: ...


class Algorithm:
    def clear(self) -> None: ...
    def empty(self) -> bool: ...
    def getDefaultName(self) -> str: ...
    def read(self, fn: FileNode) -> None: ...
    def save(self, filename: str) -> None: ...
    def write(self, fs: FileStorage, name: str = ...) -> None: ...


class AlignExposures:
    @overload
    def process(self, src: Sequence[Mat], dst: Sequence[Mat], times: Mat, response: Mat) -> None: ...
    @overload
    def process(self, src: Sequence[UMat], dst: Sequence[Mat], times: UMat, response: UMat) -> None: ...


class AlignMTB:
    @overload
    def calculateShift(self, img0: Mat, img1: Mat) -> Point: ...
    @overload
    def calculateShift(self, img0: UMat, img1: UMat) -> Point: ...
    @overload
    def computeBitmaps(self, img: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def computeBitmaps(self, img: UMat) -> Tuple[UMat, UMat]: ...
    def getCut(self) -> bool: ...
    def getExcludeRange(self) -> int: ...
    def getMaxBits(self) -> int: ...
    @overload
    def process(self, src: Sequence[Mat], dst: Sequence[Mat], times: Mat, response: Mat) -> None: ...
    @overload
    def process(self, src: Sequence[UMat], dst: Sequence[Mat], times: UMat, response: UMat) -> None: ...
    @overload
    def process(self, src: Sequence[Mat], dst: Sequence[Mat]) -> None: ...
    @overload
    def process(self, src: Sequence[UMat], dst: Sequence[Mat]) -> None: ...
    def setCut(self, value: bool) -> None: ...
    def setExcludeRange(self, exclude_range: int) -> None: ...
    def setMaxBits(self, max_bits: int) -> None: ...
    @overload
    def shiftMat(self, src: Mat, shift: Point) -> Mat: ...
    @overload
    def shiftMat(self, src: UMat, shift: Point) -> UMat: ...


class AsyncArray:
    def __init__(self) -> None: ...
    @overload
    def get(self) -> Mat: ...
    @overload
    def get(self) -> UMat: ...
    @overload
    def get(self, timeoutNs: float) -> Tuple[float, Mat]: ...
    @overload
    def get(self, timeoutNs: float) -> Tuple[float, UMat]: ...
    def release(self) -> None: ...
    def valid(self) -> bool: ...
    def wait_for(self, timeoutNs: float) -> bool: ...


class BFMatcher:
    def __init__(self, normType: int = ..., crossCheck: bool = ...) -> None: ...
    @staticmethod
    def create(normType: int = ..., crossCheck: bool = ...) -> BFMatcher: ...


class BOWImgDescriptorExtractor:
    def __init__(self, dextractor: DescriptorExtractor, dmatcher: DescriptorMatcher) -> None: ...
    @overload
    def compute(self, image: Mat, keypoints: Sequence[KeyPoint]) -> Mat: ...
    @overload
    def compute(self, image: Mat, keypoints: Sequence[KeyPoint]) -> Mat: ...
    def descriptorSize(self) -> int: ...
    def descriptorType(self) -> int: ...
    def getVocabulary(self) -> Mat: ...
    @overload
    def setVocabulary(self, vocabulary: Mat) -> None: ...
    @overload
    def setVocabulary(self, vocabulary: Mat) -> None: ...


class BOWKMeansTrainer:
    def __init__(self, clusterCount: int, termcrit: TermCriteria = ..., attempts: int = ..., flags: int = ...) -> None: ...
    @overload
    def cluster(self) -> Mat: ...
    @overload
    def cluster(self, descriptors: Mat) -> Mat: ...
    @overload
    def cluster(self, descriptors: Mat) -> Mat: ...


class BOWTrainer:
    @overload
    def add(self, descriptors: Mat) -> None: ...
    @overload
    def add(self, descriptors: Mat) -> None: ...
    def clear(self) -> None: ...
    @overload
    def cluster(self) -> Mat: ...
    @overload
    def cluster(self, descriptors: Mat) -> Mat: ...
    @overload
    def cluster(self, descriptors: Mat) -> Mat: ...
    def descriptorsCount(self) -> int: ...
    def getDescriptors(self) -> Sequence[Mat]: ...


class BRISK:
    @overload
    @staticmethod
    def create(thresh: int = ..., octaves: int = ..., patternScale: float = ...) -> BRISK: ...
    @overload
    @staticmethod
    def create(radiusList: Sequence[float], numberList: Sequence[int], dMax: float = ..., dMin: float = ..., indexChange: Sequence[int] = ...) -> BRISK: ...
    @overload
    @staticmethod
    def create(thresh: int, octaves: int, radiusList: Sequence[float], numberList: Sequence[int], dMax: float = ..., dMin: float = ..., indexChange: Sequence[int] = ...) -> BRISK: ...
    def getDefaultName(self) -> str: ...
    def getOctaves(self) -> int: ...
    def getThreshold(self) -> int: ...
    def setOctaves(self, octaves: int) -> None: ...
    def setThreshold(self, threshold: int) -> None: ...


class BackgroundSubtractor:
    @overload
    def apply(self, image: Mat, learningRate: float = ...) -> Mat: ...
    @overload
    def apply(self, image: UMat, learningRate: float = ...) -> UMat: ...
    @overload
    def getBackgroundImage(self) -> Mat: ...
    @overload
    def getBackgroundImage(self) -> UMat: ...


class BackgroundSubtractorKNN:
    def getDetectShadows(self) -> bool: ...
    def getDist2Threshold(self) -> float: ...
    def getHistory(self) -> int: ...
    def getNSamples(self) -> int: ...
    def getShadowThreshold(self) -> float: ...
    def getShadowValue(self) -> int: ...
    def getkNNSamples(self) -> int: ...
    def setDetectShadows(self, detectShadows: bool) -> None: ...
    def setDist2Threshold(self, _dist2Threshold: float) -> None: ...
    def setHistory(self, history: int) -> None: ...
    def setNSamples(self, _nN: int) -> None: ...
    def setShadowThreshold(self, threshold: float) -> None: ...
    def setShadowValue(self, value: int) -> None: ...
    def setkNNSamples(self, _nkNN: int) -> None: ...


class BackgroundSubtractorMOG2:
    @overload
    def apply(self, image: Mat, learningRate: float = ...) -> Mat: ...
    @overload
    def apply(self, image: UMat, learningRate: float = ...) -> UMat: ...
    def getBackgroundRatio(self) -> float: ...
    def getComplexityReductionThreshold(self) -> float: ...
    def getDetectShadows(self) -> bool: ...
    def getHistory(self) -> int: ...
    def getNMixtures(self) -> int: ...
    def getShadowThreshold(self) -> float: ...
    def getShadowValue(self) -> int: ...
    def getVarInit(self) -> float: ...
    def getVarMax(self) -> float: ...
    def getVarMin(self) -> float: ...
    def getVarThreshold(self) -> float: ...
    def getVarThresholdGen(self) -> float: ...
    def setBackgroundRatio(self, ratio: float) -> None: ...
    def setComplexityReductionThreshold(self, ct: float) -> None: ...
    def setDetectShadows(self, detectShadows: bool) -> None: ...
    def setHistory(self, history: int) -> None: ...
    def setNMixtures(self, nmixtures: int) -> None: ...
    def setShadowThreshold(self, threshold: float) -> None: ...
    def setShadowValue(self, value: int) -> None: ...
    def setVarInit(self, varInit: float) -> None: ...
    def setVarMax(self, varMax: float) -> None: ...
    def setVarMin(self, varMin: float) -> None: ...
    def setVarThreshold(self, varThreshold: float) -> None: ...
    def setVarThresholdGen(self, varThresholdGen: float) -> None: ...


class BaseCascadeClassifier:
    pass


class CLAHE:
    @overload
    def apply(self, src: Mat) -> Mat: ...
    @overload
    def apply(self, src: UMat) -> UMat: ...
    def collectGarbage(self) -> None: ...
    def getClipLimit(self) -> float: ...
    def getTilesGridSize(self) -> Size: ...
    def setClipLimit(self, clipLimit: float) -> None: ...
    def setTilesGridSize(self, tileGridSize: Size) -> None: ...


class CalibrateCRF:
    @overload
    def process(self, src: Sequence[Mat], times: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat) -> UMat: ...


class CalibrateDebevec:
    def getLambda(self) -> float: ...
    def getRandom(self) -> bool: ...
    def getSamples(self) -> int: ...
    def setLambda(self, lambda: float) -> None: ...
    def setRandom(self, random: bool) -> None: ...
    def setSamples(self, samples: int) -> None: ...


class CalibrateRobertson:
    def getMaxIter(self) -> int: ...
    def getRadiance(self) -> Mat: ...
    def getThreshold(self) -> float: ...
    def setMaxIter(self, max_iter: int) -> None: ...
    def setThreshold(self, threshold: float) -> None: ...


class CascadeClassifier:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, filename: str) -> None: ...
    @staticmethod
    def convert(oldcascade: str, newcascade: str) -> bool: ...
    @overload
    def detectMultiScale(self, image: Mat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ...) -> Sequence[Rect]: ...
    @overload
    def detectMultiScale(self, image: UMat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ...) -> Sequence[Rect]: ...
    @overload
    def detectMultiScale2(self, image: Mat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ...) -> Tuple[Sequence[Rect], Sequence[int]]: ...
    @overload
    def detectMultiScale2(self, image: UMat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ...) -> Tuple[Sequence[Rect], Sequence[int]]: ...
    @overload
    def detectMultiScale3(self, image: Mat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ..., outputRejectLevels: bool = ...) -> Tuple[Sequence[Rect], Sequence[int], Sequence[float]]: ...
    @overload
    def detectMultiScale3(self, image: UMat, scaleFactor: float = ..., minNeighbors: int = ..., flags: int = ..., minSize: Size = ..., maxSize: Size = ..., outputRejectLevels: bool = ...) -> Tuple[Sequence[Rect], Sequence[int], Sequence[float]]: ...
    def empty(self) -> bool: ...
    def getFeatureType(self) -> int: ...
    def getOriginalWindowSize(self) -> Size: ...
    def isOldFormatCascade(self) -> bool: ...
    def load(self, filename: str) -> bool: ...
    def read(self, node: FileNode) -> bool: ...


class CirclesGridFinderParameters:
    convexHullFactor: float
    densityNeighborhoodSize: Size2f
    edgeGain: float
    edgePenalty: float
    existingVertexGain: float
    keypointScale: int
    kmeansAttempts: int
    maxRectifiedDistance: float
    minDensity: float
    minDistanceToAddKeypoint: int
    minGraphConfidence: float
    minRNGEdgeSwitchDist: float
    squareSize: float
    vertexGain: float
    vertexPenalty: float
    def __init__(self) -> None: ...


class DISOpticalFlow:
    @staticmethod
    def create(preset: int = ...) -> DISOpticalFlow: ...
    def getFinestScale(self) -> int: ...
    def getGradientDescentIterations(self) -> int: ...
    def getPatchSize(self) -> int: ...
    def getPatchStride(self) -> int: ...
    def getUseMeanNormalization(self) -> bool: ...
    def getUseSpatialPropagation(self) -> bool: ...
    def getVariationalRefinementAlpha(self) -> float: ...
    def getVariationalRefinementDelta(self) -> float: ...
    def getVariationalRefinementGamma(self) -> float: ...
    def getVariationalRefinementIterations(self) -> int: ...
    def setFinestScale(self, val: int) -> None: ...
    def setGradientDescentIterations(self, val: int) -> None: ...
    def setPatchSize(self, val: int) -> None: ...
    def setPatchStride(self, val: int) -> None: ...
    def setUseMeanNormalization(self, val: bool) -> None: ...
    def setUseSpatialPropagation(self, val: bool) -> None: ...
    def setVariationalRefinementAlpha(self, val: float) -> None: ...
    def setVariationalRefinementDelta(self, val: float) -> None: ...
    def setVariationalRefinementGamma(self, val: float) -> None: ...
    def setVariationalRefinementIterations(self, val: int) -> None: ...


class DMatch:
    distance: float
    imgIdx: int
    queryIdx: int
    trainIdx: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _queryIdx: int, _trainIdx: int, _distance: float) -> None: ...
    @overload
    def __init__(self, _queryIdx: int, _trainIdx: int, _imgIdx: int, _distance: float) -> None: ...


class DenseOpticalFlow:
    @overload
    def calc(self, I0: Mat, I1: Mat) -> Mat: ...
    @overload
    def calc(self, I0: UMat, I1: UMat) -> UMat: ...
    def collectGarbage(self) -> None: ...


class DescriptorMatcher:
    @overload
    def add(self, descriptors: Sequence[Mat]) -> None: ...
    @overload
    def add(self, descriptors: Sequence[UMat]) -> None: ...
    def clear(self) -> None: ...
    def clone(self, emptyTrainData: bool = ...) -> DescriptorMatcher: ...
    @overload
    @staticmethod
    def create(descriptorMatcherType: str) -> DescriptorMatcher: ...
    @overload
    @staticmethod
    def create(matcherType: DescriptorMatcher_MatcherType) -> DescriptorMatcher: ...
    def empty(self) -> bool: ...
    def getTrainDescriptors(self) -> Sequence[Mat]: ...
    def isMaskSupported(self) -> bool: ...
    @overload
    def knnMatch(self, queryDescriptors: Mat, trainDescriptors: Mat, k: int, mask: Mat = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def knnMatch(self, queryDescriptors: UMat, trainDescriptors: UMat, k: int, mask: UMat = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def knnMatch(self, queryDescriptors: Mat, k: int, masks: Sequence[Mat] = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def knnMatch(self, queryDescriptors: UMat, k: int, masks: Sequence[UMat] = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def match(self, queryDescriptors: Mat, trainDescriptors: Mat, mask: Mat = ...) -> Sequence[DMatch]: ...
    @overload
    def match(self, queryDescriptors: UMat, trainDescriptors: UMat, mask: UMat = ...) -> Sequence[DMatch]: ...
    @overload
    def match(self, queryDescriptors: Mat, masks: Sequence[Mat] = ...) -> Sequence[DMatch]: ...
    @overload
    def match(self, queryDescriptors: UMat, masks: Sequence[UMat] = ...) -> Sequence[DMatch]: ...
    @overload
    def radiusMatch(self, queryDescriptors: Mat, trainDescriptors: Mat, maxDistance: float, mask: Mat = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def radiusMatch(self, queryDescriptors: UMat, trainDescriptors: UMat, maxDistance: float, mask: UMat = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def radiusMatch(self, queryDescriptors: Mat, maxDistance: float, masks: Sequence[Mat] = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def radiusMatch(self, queryDescriptors: UMat, maxDistance: float, masks: Sequence[UMat] = ..., compactResult: bool = ...) -> Sequence[Sequence[DMatch]]: ...
    @overload
    def read(self, fileName: str) -> None: ...
    @overload
    def read(self, arg1: FileNode) -> None: ...
    def train(self) -> None: ...
    @overload
    def write(self, fileName: str) -> None: ...
    @overload
    def write(self, fs: FileStorage, name: str = ...) -> None: ...


class FarnebackOpticalFlow:
    @staticmethod
    def create(numLevels: int = ..., pyrScale: float = ..., fastPyramids: bool = ..., winSize: int = ..., numIters: int = ..., polyN: int = ..., polySigma: float = ..., flags: int = ...) -> FarnebackOpticalFlow: ...
    def getFastPyramids(self) -> bool: ...
    def getFlags(self) -> int: ...
    def getNumIters(self) -> int: ...
    def getNumLevels(self) -> int: ...
    def getPolyN(self) -> int: ...
    def getPolySigma(self) -> float: ...
    def getPyrScale(self) -> float: ...
    def getWinSize(self) -> int: ...
    def setFastPyramids(self, fastPyramids: bool) -> None: ...
    def setFlags(self, flags: int) -> None: ...
    def setNumIters(self, numIters: int) -> None: ...
    def setNumLevels(self, numLevels: int) -> None: ...
    def setPolyN(self, polyN: int) -> None: ...
    def setPolySigma(self, polySigma: float) -> None: ...
    def setPyrScale(self, pyrScale: float) -> None: ...
    def setWinSize(self, winSize: int) -> None: ...


class FastFeatureDetector:
    @staticmethod
    def create(threshold: int = ..., nonmaxSuppression: bool = ..., type: FastFeatureDetector_DetectorType = ...) -> FastFeatureDetector: ...
    def getDefaultName(self) -> str: ...
    def getNonmaxSuppression(self) -> bool: ...
    def getThreshold(self) -> int: ...
    def getType(self) -> FastFeatureDetector_DetectorType: ...
    def setNonmaxSuppression(self, f: bool) -> None: ...
    def setThreshold(self, threshold: int) -> None: ...
    def setType(self, type: FastFeatureDetector_DetectorType) -> None: ...


class Feature2D:
    @overload
    def compute(self, image: Mat) -> Tuple[Sequence[KeyPoint], Mat]: ...
    @overload
    def compute(self, image: UMat) -> Tuple[Sequence[KeyPoint], UMat]: ...
    @overload
    def compute(self, images: Sequence[Mat]) -> Tuple[Sequence[Sequence[KeyPoint]], Sequence[Mat]]: ...
    @overload
    def compute(self, images: Sequence[UMat]) -> Tuple[Sequence[Sequence[KeyPoint]], Sequence[UMat]]: ...
    def defaultNorm(self) -> int: ...
    def descriptorSize(self) -> int: ...
    def descriptorType(self) -> int: ...
    @overload
    def detect(self, image: Mat, mask: Mat = ...) -> Sequence[KeyPoint]: ...
    @overload
    def detect(self, image: UMat, mask: UMat = ...) -> Sequence[KeyPoint]: ...
    @overload
    def detect(self, images: Sequence[Mat], masks: Sequence[Mat] = ...) -> Sequence[Sequence[KeyPoint]]: ...
    @overload
    def detect(self, images: Sequence[UMat], masks: Sequence[UMat] = ...) -> Sequence[Sequence[KeyPoint]]: ...
    @overload
    def detectAndCompute(self, image: Mat, mask: Mat, useProvidedKeypoints: bool = ...) -> Tuple[Sequence[KeyPoint], Mat]: ...
    @overload
    def detectAndCompute(self, image: UMat, mask: UMat, useProvidedKeypoints: bool = ...) -> Tuple[Sequence[KeyPoint], UMat]: ...
    def empty(self) -> bool: ...
    def getDefaultName(self) -> str: ...
    @overload
    def read(self, fileName: str) -> None: ...
    @overload
    def read(self, arg1: FileNode) -> None: ...
    @overload
    def write(self, fileName: str) -> None: ...
    @overload
    def write(self, fs: FileStorage, name: str = ...) -> None: ...


class FileNode:
    def __init__(self) -> None: ...
    def at(self, i: int) -> FileNode: ...
    def empty(self) -> bool: ...
    def getNode(self, nodename: str) -> FileNode: ...
    def isInt(self) -> bool: ...
    def isMap(self) -> bool: ...
    def isNamed(self) -> bool: ...
    def isNone(self) -> bool: ...
    def isReal(self) -> bool: ...
    def isSeq(self) -> bool: ...
    def isString(self) -> bool: ...
    def keys(self) -> Sequence[str]: ...
    def mat(self) -> Mat: ...
    def name(self) -> str: ...
    def rawSize(self) -> int: ...
    def real(self) -> float: ...
    def size(self) -> int: ...
    def string(self) -> str: ...
    def type(self) -> int: ...


class FileStorage:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, filename: str, flags: int, encoding: str = ...) -> None: ...
    def endWriteStruct(self) -> None: ...
    def getFirstTopLevelNode(self) -> FileNode: ...
    def getFormat(self) -> int: ...
    def getNode(self, nodename: str) -> FileNode: ...
    def isOpened(self) -> bool: ...
    def open(self, filename: str, flags: int, encoding: str = ...) -> bool: ...
    def release(self) -> None: ...
    def releaseAndGetString(self) -> str: ...
    def root(self, streamidx: int = ...) -> FileNode: ...
    def startWriteStruct(self, name: str, flags: int, typeName: str = ...) -> None: ...
    @overload
    def write(self, name: str, val: int) -> None: ...
    @overload
    def write(self, name: str, val: float) -> None: ...
    @overload
    def write(self, name: str, val: str) -> None: ...
    @overload
    def write(self, name: str, val: Mat) -> None: ...
    @overload
    def write(self, name: str, val: Mat) -> None: ...
    @overload
    def write(self, name: str, val: Sequence[str]) -> None: ...
    def writeComment(self, comment: str, append: bool = ...) -> None: ...


class Filter2DParams:
    anchorX: int
    anchorY: int
    borderType: int
    ddepth: int
    scale: float
    shift: float


class FlannBasedMatcher:
    def __init__(self, indexParams: flann_IndexParams = ..., searchParams: flann_SearchParams = ...) -> None: ...
    @staticmethod
    def create() -> FlannBasedMatcher: ...


class FontFace:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, fontPathOrName: str) -> None: ...
    def getInstance(self) -> Tuple[Sequence[int], Sequence[int]]: ...
    def getName(self) -> str: ...
    def set(self, fontPathOrName: str) -> bool: ...
    def setInstance(self, params: Sequence[int]) -> bool: ...


class GArrayDesc:
    pass


class GArrayT:
    def __init__(self, type: gapi_ArgType) -> None: ...
    def type(self) -> gapi_ArgType: ...


class GCompileArg:
    pass


class GComputation:
    @overload
    def __init__(self, std::move(ins): GProtoInputArgs, std::move(outs): GProtoOutputArgs) -> None: ...
    @overload
    def __init__(self, in: GMat, out: GMat) -> None: ...
    @overload
    def __init__(self, in: GMat, out: GScalar) -> None: ...
    @overload
    def __init__(self, in1: GMat, in2: GMat, out: GMat) -> None: ...
    def apply(self, callback: detail_ExtractArgsCallback, std::move(args): GCompileArgs = ...) -> GRunArgs: ...
    @overload
    def compileStreaming(self, callback: detail_ExtractMetaCallback, std::move(args): GCompileArgs = ...) -> GStreamingCompiled: ...
    @overload
    def compileStreaming(self, std::move(args): GCompileArgs = ...) -> GStreamingCompiled: ...


class GFTTDetector:
    @overload
    @staticmethod
    def create(maxCorners: int = ..., qualityLevel: float = ..., minDistance: float = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> GFTTDetector: ...
    @overload
    @staticmethod
    def create(maxCorners: int, qualityLevel: float, minDistance: float, blockSize: int, gradiantSize: int, useHarrisDetector: bool = ..., k: float = ...) -> GFTTDetector: ...
    def getBlockSize(self) -> int: ...
    def getDefaultName(self) -> str: ...
    def getHarrisDetector(self) -> bool: ...
    def getK(self) -> float: ...
    def getMaxFeatures(self) -> int: ...
    def getMinDistance(self) -> float: ...
    def getQualityLevel(self) -> float: ...
    def setBlockSize(self, blockSize: int) -> None: ...
    def setHarrisDetector(self, val: bool) -> None: ...
    def setK(self, k: float) -> None: ...
    def setMaxFeatures(self, maxFeatures: int) -> None: ...
    def setMinDistance(self, minDistance: float) -> None: ...
    def setQualityLevel(self, qlevel: float) -> None: ...


class GFrame:
    pass


class GInferInputs:
    def __init__(self) -> None: ...
    @overload
    def setInput(self, name: str, value: GMat) -> None: ...
    @overload
    def setInput(self, name: str, value: GFrame) -> None: ...


class GInferListInputs:
    def __init__(self) -> None: ...
    @overload
    def setInput(self, name: str, value: GArray_GMat) -> None: ...
    @overload
    def setInput(self, name: str, value: GArray_Rect) -> None: ...


class GInferListOutputs:
    def __init__(self) -> None: ...
    def at(self, name: str) -> GArray<cv_GMat>: ...


class GInferOutputs:
    def __init__(self) -> None: ...
    def at(self, name: str) -> GMat: ...


class GMat:
    pass


class GMatDesc:
    chan: int
    depth: int
    dims: Sequence[int]
    planar: bool
    size: Size
    @overload
    def __init__(self, d: int, c: int, s: Size, p: bool = ...) -> None: ...
    @overload
    def __init__(self, d: int, dd: Sequence[int]) -> None: ...
    @overload
    def __init__(self, d: int, std::move(dd): Sequence[int]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    def asInterleaved(self) -> GMatDesc: ...
    @overload
    def asPlanar(self) -> GMatDesc: ...
    @overload
    def asPlanar(self, planes: int) -> GMatDesc: ...
    def withDepth(self, ddepth: int) -> GMatDesc: ...
    def withSize(self, sz: Size) -> GMatDesc: ...
    @overload
    def withSizeDelta(self, delta: Size) -> GMatDesc: ...
    @overload
    def withSizeDelta(self, dx: int, dy: int) -> GMatDesc: ...
    def withType(self, ddepth: int, dchan: int) -> GMatDesc: ...


class GMetaArg:
    pass


class GOpaqueDesc:
    pass


class GOpaqueT:
    def __init__(self, type: gapi_ArgType) -> None: ...
    def type(self) -> gapi_ArgType: ...


class GProtoArg:
    pass


class GProtoInputArgs:
    pass


class GProtoOutputArgs:
    pass


class GRunArg:
    pass


class GScalar:
    pass


class GScalarDesc:
    pass


class GStreamingCompiled:
    def __init__(self) -> None: ...
    def pull(self) -> Tuple[bool, cv_GRunArgs]: ...
    def running(self) -> bool: ...
    @overload
    def setSource(self, callback: detail_ExtractArgsCallback) -> None: ...
    @overload
    def setSource(self, s: gapi_wip_IStreamSource_Ptr) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...


class GeneralizedHough:
    @overload
    def detect(self, image: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def detect(self, image: UMat) -> Tuple[UMat, UMat]: ...
    @overload
    def detect(self, edges: Mat, dx: Mat, dy: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def detect(self, edges: UMat, dx: UMat, dy: UMat) -> Tuple[UMat, UMat]: ...
    def getCannyHighThresh(self) -> int: ...
    def getCannyLowThresh(self) -> int: ...
    def getDp(self) -> float: ...
    def getMaxBufferSize(self) -> int: ...
    def getMinDist(self) -> float: ...
    def setCannyHighThresh(self, cannyHighThresh: int) -> None: ...
    def setCannyLowThresh(self, cannyLowThresh: int) -> None: ...
    def setDp(self, dp: float) -> None: ...
    def setMaxBufferSize(self, maxBufferSize: int) -> None: ...
    def setMinDist(self, minDist: float) -> None: ...
    @overload
    def setTemplate(self, templ: Mat, templCenter: Point = ...) -> None: ...
    @overload
    def setTemplate(self, templ: UMat, templCenter: Point = ...) -> None: ...
    @overload
    def setTemplate(self, edges: Mat, dx: Mat, dy: Mat, templCenter: Point = ...) -> None: ...
    @overload
    def setTemplate(self, edges: UMat, dx: UMat, dy: UMat, templCenter: Point = ...) -> None: ...


class GeneralizedHoughBallard:
    def getLevels(self) -> int: ...
    def getVotesThreshold(self) -> int: ...
    def setLevels(self, levels: int) -> None: ...
    def setVotesThreshold(self, votesThreshold: int) -> None: ...


class GeneralizedHoughGuil:
    def getAngleEpsilon(self) -> float: ...
    def getAngleStep(self) -> float: ...
    def getAngleThresh(self) -> int: ...
    def getLevels(self) -> int: ...
    def getMaxAngle(self) -> float: ...
    def getMaxScale(self) -> float: ...
    def getMinAngle(self) -> float: ...
    def getMinScale(self) -> float: ...
    def getPosThresh(self) -> int: ...
    def getScaleStep(self) -> float: ...
    def getScaleThresh(self) -> int: ...
    def getXi(self) -> float: ...
    def setAngleEpsilon(self, angleEpsilon: float) -> None: ...
    def setAngleStep(self, angleStep: float) -> None: ...
    def setAngleThresh(self, angleThresh: int) -> None: ...
    def setLevels(self, levels: int) -> None: ...
    def setMaxAngle(self, maxAngle: float) -> None: ...
    def setMaxScale(self, maxScale: float) -> None: ...
    def setMinAngle(self, minAngle: float) -> None: ...
    def setMinScale(self, minScale: float) -> None: ...
    def setPosThresh(self, posThresh: int) -> None: ...
    def setScaleStep(self, scaleStep: float) -> None: ...
    def setScaleThresh(self, scaleThresh: int) -> None: ...
    def setXi(self, xi: float) -> None: ...


class HOGDescriptor:
    L2HysThreshold: float
    blockSize: Size
    blockStride: Size
    cellSize: Size
    derivAperture: int
    gammaCorrection: bool
    histogramNormType: HOGDescriptor_HistogramNormType
    nbins: int
    nlevels: int
    signedGradient: bool
    svmDetector: Sequence[float]
    winSigma: float
    winSize: Size
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _winSize: Size, _blockSize: Size, _blockStride: Size, _cellSize: Size, _nbins: int, _derivAperture: int = ..., _winSigma: float = ..., _histogramNormType: HOGDescriptor_HistogramNormType = ..., _L2HysThreshold: float = ..., _gammaCorrection: bool = ..., _nlevels: int = ..., _signedGradient: bool = ...) -> None: ...
    @overload
    def __init__(self, filename: str) -> None: ...
    def checkDetectorSize(self) -> bool: ...
    @overload
    def compute(self, img: Mat, winStride: Size = ..., padding: Size = ..., locations: Sequence[Point] = ...) -> Sequence[float]: ...
    @overload
    def compute(self, img: UMat, winStride: Size = ..., padding: Size = ..., locations: Sequence[Point] = ...) -> Sequence[float]: ...
    @overload
    def computeGradient(self, img: Mat, paddingTL: Size = ..., paddingBR: Size = ...) -> Tuple[Mat, Mat]: ...
    @overload
    def computeGradient(self, img: UMat, paddingTL: Size = ..., paddingBR: Size = ...) -> Tuple[UMat, UMat]: ...
    @overload
    def detect(self, img: Mat, hitThreshold: float = ..., winStride: Size = ..., padding: Size = ..., searchLocations: Sequence[Point] = ...) -> Tuple[Sequence[Point], Sequence[float]]: ...
    @overload
    def detect(self, img: UMat, hitThreshold: float = ..., winStride: Size = ..., padding: Size = ..., searchLocations: Sequence[Point] = ...) -> Tuple[Sequence[Point], Sequence[float]]: ...
    @overload
    def detectMultiScale(self, img: Mat, hitThreshold: float = ..., winStride: Size = ..., padding: Size = ..., scale: float = ..., finalThreshold: float = ..., useMeanshiftGrouping: bool = ...) -> Tuple[Sequence[Rect], Sequence[float]]: ...
    @overload
    def detectMultiScale(self, img: UMat, hitThreshold: float = ..., winStride: Size = ..., padding: Size = ..., scale: float = ..., finalThreshold: float = ..., useMeanshiftGrouping: bool = ...) -> Tuple[Sequence[Rect], Sequence[float]]: ...
    @staticmethod
    def getDaimlerPeopleDetector() -> Sequence[float]: ...
    @staticmethod
    def getDefaultPeopleDetector() -> Sequence[float]: ...
    def getDescriptorSize(self) -> int: ...
    def getWinSigma(self) -> float: ...
    def load(self, filename: str, objname: str = ...) -> bool: ...
    def save(self, filename: str, objname: str = ...) -> None: ...
    @overload
    def setSVMDetector(self, svmdetector: Mat) -> None: ...
    @overload
    def setSVMDetector(self, svmdetector: UMat) -> None: ...


class KAZE:
    @staticmethod
    def create(extended: bool = ..., upright: bool = ..., threshold: float = ..., nOctaves: int = ..., nOctaveLayers: int = ..., diffusivity: KAZE_DiffusivityType = ...) -> KAZE: ...
    def getDefaultName(self) -> str: ...
    def getDiffusivity(self) -> KAZE_DiffusivityType: ...
    def getExtended(self) -> bool: ...
    def getNOctaveLayers(self) -> int: ...
    def getNOctaves(self) -> int: ...
    def getThreshold(self) -> float: ...
    def getUpright(self) -> bool: ...
    def setDiffusivity(self, diff: KAZE_DiffusivityType) -> None: ...
    def setExtended(self, extended: bool) -> None: ...
    def setNOctaveLayers(self, octaveLayers: int) -> None: ...
    def setNOctaves(self, octaves: int) -> None: ...
    def setThreshold(self, threshold: float) -> None: ...
    def setUpright(self, upright: bool) -> None: ...


class KalmanFilter:
    controlMatrix: Mat
    errorCovPost: Mat
    errorCovPre: Mat
    gain: Mat
    measurementMatrix: Mat
    measurementNoiseCov: Mat
    processNoiseCov: Mat
    statePost: Mat
    statePre: Mat
    transitionMatrix: Mat
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dynamParams: int, measureParams: int, controlParams: int = ..., type: int = ...) -> None: ...
    @overload
    def correct(self, measurement: Mat) -> Mat: ...
    @overload
    def correct(self, measurement: Mat) -> Mat: ...
    @overload
    def predict(self, control: Mat = ...) -> Mat: ...
    @overload
    def predict(self, control: Mat = ...) -> Mat: ...


class KeyPoint:
    angle: float
    class_id: int
    octave: int
    pt: Point2f
    response: float
    size: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: float, y: float, size: float, angle: float = ..., response: float = ..., octave: int = ..., class_id: int = ...) -> None: ...
    @overload
    @staticmethod
    def convert(keypoints: Sequence[KeyPoint], keypointIndexes: Sequence[int] = ...) -> Sequence[Point2f]: ...
    @overload
    @staticmethod
    def convert(points2f: Sequence[Point2f], size: float = ..., response: float = ..., octave: int = ..., class_id: int = ...) -> Sequence[KeyPoint]: ...
    @staticmethod
    def overlap(kp1: KeyPoint, kp2: KeyPoint) -> float: ...


class MSER:
    @staticmethod
    def create(delta: int = ..., min_area: int = ..., max_area: int = ..., max_variation: float = ..., min_diversity: float = ..., max_evolution: int = ..., area_threshold: float = ..., min_margin: float = ..., edge_blur_size: int = ...) -> MSER: ...
    @overload
    def detectRegions(self, image: Mat) -> Tuple[Sequence[Sequence[Point]], Sequence[Rect]]: ...
    @overload
    def detectRegions(self, image: UMat) -> Tuple[Sequence[Sequence[Point]], Sequence[Rect]]: ...
    def getDefaultName(self) -> str: ...
    def getDelta(self) -> int: ...
    def getMaxArea(self) -> int: ...
    def getMinArea(self) -> int: ...
    def getMinDiversity(self) -> float: ...
    def getPass2Only(self) -> bool: ...
    def setDelta(self, delta: int) -> None: ...
    def setMaxArea(self, maxArea: int) -> None: ...
    def setMinArea(self, minArea: int) -> None: ...
    def setMinDiversity(self, minDiversity: float) -> None: ...
    def setPass2Only(self, f: bool) -> None: ...


class MergeDebevec:
    @overload
    def process(self, src: Sequence[Mat], times: Mat, response: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat, response: UMat) -> UMat: ...
    @overload
    def process(self, src: Sequence[Mat], times: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat) -> UMat: ...


class MergeExposures:
    @overload
    def process(self, src: Sequence[Mat], times: Mat, response: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat, response: UMat) -> UMat: ...


class MergeMertens:
    def getContrastWeight(self) -> float: ...
    def getExposureWeight(self) -> float: ...
    def getSaturationWeight(self) -> float: ...
    @overload
    def process(self, src: Sequence[Mat], times: Mat, response: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat, response: UMat) -> UMat: ...
    @overload
    def process(self, src: Sequence[Mat]) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat]) -> UMat: ...
    def setContrastWeight(self, contrast_weiht: float) -> None: ...
    def setExposureWeight(self, exposure_weight: float) -> None: ...
    def setSaturationWeight(self, saturation_weight: float) -> None: ...


class MergeRobertson:
    @overload
    def process(self, src: Sequence[Mat], times: Mat, response: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat, response: UMat) -> UMat: ...
    @overload
    def process(self, src: Sequence[Mat], times: Mat) -> Mat: ...
    @overload
    def process(self, src: Sequence[UMat], times: UMat) -> UMat: ...


class Moments:
    m00: float
    m01: float
    m02: float
    m03: float
    m10: float
    m11: float
    m12: float
    m20: float
    m21: float
    m30: float
    mu02: float
    mu03: float
    mu11: float
    mu12: float
    mu20: float
    mu21: float
    mu30: float
    nu02: float
    nu03: float
    nu11: float
    nu12: float
    nu20: float
    nu21: float
    nu30: float


class ORB:
    @staticmethod
    def create(nfeatures: int = ..., scaleFactor: float = ..., nlevels: int = ..., edgeThreshold: int = ..., firstLevel: int = ..., WTA_K: int = ..., scoreType: ORB_ScoreType = ..., patchSize: int = ..., fastThreshold: int = ...) -> ORB: ...
    def getDefaultName(self) -> str: ...
    def getEdgeThreshold(self) -> int: ...
    def getFastThreshold(self) -> int: ...
    def getFirstLevel(self) -> int: ...
    def getMaxFeatures(self) -> int: ...
    def getNLevels(self) -> int: ...
    def getPatchSize(self) -> int: ...
    def getScaleFactor(self) -> float: ...
    def getScoreType(self) -> ORB_ScoreType: ...
    def getWTA_K(self) -> int: ...
    def setEdgeThreshold(self, edgeThreshold: int) -> None: ...
    def setFastThreshold(self, fastThreshold: int) -> None: ...
    def setFirstLevel(self, firstLevel: int) -> None: ...
    def setMaxFeatures(self, maxFeatures: int) -> None: ...
    def setNLevels(self, nlevels: int) -> None: ...
    def setPatchSize(self, patchSize: int) -> None: ...
    def setScaleFactor(self, scaleFactor: float) -> None: ...
    def setScoreType(self, scoreType: ORB_ScoreType) -> None: ...
    def setWTA_K(self, wta_k: int) -> None: ...


class PyRotationWarper:
    @overload
    def __init__(self, type: str, scale: float) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def buildMaps(self, src_size: Size, K: Mat, R: Mat) -> Tuple[Mat, Mat, Mat]: ...
    @overload
    def buildMaps(self, src_size: Size, K: UMat, R: UMat) -> Tuple[UMat, UMat, UMat]: ...
    def getScale(self) -> float: ...
    def setScale(self, arg1: float) -> None: ...
    @overload
    def warp(self, src: Mat, K: Mat, R: Mat, interp_mode: int, border_mode: int) -> Tuple[Mat, Mat]: ...
    @overload
    def warp(self, src: UMat, K: UMat, R: UMat, interp_mode: int, border_mode: int) -> Tuple[UMat, UMat]: ...
    @overload
    def warpBackward(self, src: Mat, K: Mat, R: Mat, interp_mode: int, border_mode: int, dst_size: Size) -> Mat: ...
    @overload
    def warpBackward(self, src: UMat, K: UMat, R: UMat, interp_mode: int, border_mode: int, dst_size: Size) -> UMat: ...
    @overload
    def warpPoint(self, pt: Point2f, K: Mat, R: Mat) -> Point2f: ...
    @overload
    def warpPoint(self, pt: Point2f, K: UMat, R: UMat) -> Point2f: ...
    @overload
    def warpPointBackward(self, pt: Point2f, K: Mat, R: Mat) -> Point2f: ...
    @overload
    def warpPointBackward(self, pt: Point2f, K: UMat, R: UMat) -> Point2f: ...
    @overload
    def warpPointBackward(self, pt: Point2f, K: Mat, R: Mat) -> Point2f: ...
    @overload
    def warpPointBackward(self, pt: Point2f, K: UMat, R: UMat) -> Point2f: ...
    @overload
    def warpRoi(self, src_size: Size, K: Mat, R: Mat) -> Rect: ...
    @overload
    def warpRoi(self, src_size: Size, K: UMat, R: UMat) -> Rect: ...


class QRCodeDetector:
    def __init__(self) -> None: ...
    @overload
    def decode(self, img: Mat, points: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def decode(self, img: UMat, points: UMat) -> Tuple[UMat, UMat]: ...
    @overload
    def decodeCurved(self, img: Mat, points: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def decodeCurved(self, img: UMat, points: UMat) -> Tuple[UMat, UMat]: ...
    @overload
    def decodeMulti(self, img: Mat, points: Mat) -> Tuple[Sequence[Mat], Sequence[str], Sequence[Mat]]: ...
    @overload
    def decodeMulti(self, img: UMat, points: UMat) -> Tuple[Sequence[UMat], Sequence[str], Sequence[UMat]]: ...
    @overload
    def detect(self, img: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def detect(self, img: UMat) -> Tuple[UMat, UMat]: ...
    @overload
    def detectAndDecode(self, img: Mat) -> Tuple[Mat, Mat, Mat]: ...
    @overload
    def detectAndDecode(self, img: UMat) -> Tuple[UMat, UMat, UMat]: ...
    @overload
    def detectAndDecodeCurved(self, img: Mat) -> Tuple[Mat, Mat, Mat]: ...
    @overload
    def detectAndDecodeCurved(self, img: UMat) -> Tuple[UMat, UMat, UMat]: ...
    @overload
    def detectAndDecodeMulti(self, img: Mat) -> Tuple[Sequence[Mat], Sequence[str], Mat, Sequence[Mat]]: ...
    @overload
    def detectAndDecodeMulti(self, img: UMat) -> Tuple[Sequence[UMat], Sequence[str], UMat, Sequence[UMat]]: ...
    @overload
    def detectMulti(self, img: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def detectMulti(self, img: UMat) -> Tuple[UMat, UMat]: ...
    def setEpsX(self, epsX: float) -> None: ...
    def setEpsY(self, epsY: float) -> None: ...


class SIFT:
    @overload
    @staticmethod
    def create(nfeatures: int = ..., nOctaveLayers: int = ..., contrastThreshold: float = ..., edgeThreshold: float = ..., sigma: float = ...) -> SIFT: ...
    @overload
    @staticmethod
    def create(nfeatures: int, nOctaveLayers: int, contrastThreshold: float, edgeThreshold: float, sigma: float, descriptorType: int) -> SIFT: ...
    def getDefaultName(self) -> str: ...


class SimpleBlobDetector:
    @staticmethod
    def create(parameters: SimpleBlobDetector_Params = ...) -> SimpleBlobDetector: ...
    def getDefaultName(self) -> str: ...


class SimpleBlobDetector_Params:
    blobColor: uchar
    filterByArea: bool
    filterByCircularity: bool
    filterByColor: bool
    filterByConvexity: bool
    filterByInertia: bool
    maxArea: float
    maxCircularity: float
    maxConvexity: float
    maxInertiaRatio: float
    maxThreshold: float
    minArea: float
    minCircularity: float
    minConvexity: float
    minDistBetweenBlobs: float
    minInertiaRatio: float
    minRepeatability: int
    minThreshold: float
    thresholdStep: float
    def __init__(self) -> None: ...


class SparseOpticalFlow:
    @overload
    def calc(self, prevImg: Mat, nextImg: Mat, prevPts: Mat) -> Tuple[Mat, Mat, Mat]: ...
    @overload
    def calc(self, prevImg: UMat, nextImg: UMat, prevPts: UMat) -> Tuple[UMat, UMat, UMat]: ...


class SparsePyrLKOpticalFlow:
    @staticmethod
    def create(winSize: Size = ..., maxLevel: int = ..., crit: TermCriteria = ..., flags: int = ..., minEigThreshold: float = ...) -> SparsePyrLKOpticalFlow: ...
    def getFlags(self) -> int: ...
    def getMaxLevel(self) -> int: ...
    def getMinEigThreshold(self) -> float: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getWinSize(self) -> Size: ...
    def setFlags(self, flags: int) -> None: ...
    def setMaxLevel(self, maxLevel: int) -> None: ...
    def setMinEigThreshold(self, minEigThreshold: float) -> None: ...
    def setTermCriteria(self, crit: TermCriteria) -> None: ...
    def setWinSize(self, winSize: Size) -> None: ...


class StereoBM:
    @staticmethod
    def create(numDisparities: int = ..., blockSize: int = ...) -> StereoBM: ...
    def getPreFilterCap(self) -> int: ...
    def getPreFilterSize(self) -> int: ...
    def getPreFilterType(self) -> int: ...
    def getROI1(self) -> Rect: ...
    def getROI2(self) -> Rect: ...
    def getSmallerBlockSize(self) -> int: ...
    def getTextureThreshold(self) -> int: ...
    def getUniquenessRatio(self) -> int: ...
    def setPreFilterCap(self, preFilterCap: int) -> None: ...
    def setPreFilterSize(self, preFilterSize: int) -> None: ...
    def setPreFilterType(self, preFilterType: int) -> None: ...
    def setROI1(self, roi1: Rect) -> None: ...
    def setROI2(self, roi2: Rect) -> None: ...
    def setSmallerBlockSize(self, blockSize: int) -> None: ...
    def setTextureThreshold(self, textureThreshold: int) -> None: ...
    def setUniquenessRatio(self, uniquenessRatio: int) -> None: ...


class StereoMatcher:
    @overload
    def compute(self, left: Mat, right: Mat) -> Mat: ...
    @overload
    def compute(self, left: UMat, right: UMat) -> UMat: ...
    def getBlockSize(self) -> int: ...
    def getDisp12MaxDiff(self) -> int: ...
    def getMinDisparity(self) -> int: ...
    def getNumDisparities(self) -> int: ...
    def getSpeckleRange(self) -> int: ...
    def getSpeckleWindowSize(self) -> int: ...
    def setBlockSize(self, blockSize: int) -> None: ...
    def setDisp12MaxDiff(self, disp12MaxDiff: int) -> None: ...
    def setMinDisparity(self, minDisparity: int) -> None: ...
    def setNumDisparities(self, numDisparities: int) -> None: ...
    def setSpeckleRange(self, speckleRange: int) -> None: ...
    def setSpeckleWindowSize(self, speckleWindowSize: int) -> None: ...


class StereoSGBM:
    @staticmethod
    def create(minDisparity: int = ..., numDisparities: int = ..., blockSize: int = ..., P1: int = ..., P2: int = ..., disp12MaxDiff: int = ..., preFilterCap: int = ..., uniquenessRatio: int = ..., speckleWindowSize: int = ..., speckleRange: int = ..., mode: int = ...) -> StereoSGBM: ...
    def getMode(self) -> int: ...
    def getP1(self) -> int: ...
    def getP2(self) -> int: ...
    def getPreFilterCap(self) -> int: ...
    def getUniquenessRatio(self) -> int: ...
    def setMode(self, mode: int) -> None: ...
    def setP1(self, P1: int) -> None: ...
    def setP2(self, P2: int) -> None: ...
    def setPreFilterCap(self, preFilterCap: int) -> None: ...
    def setUniquenessRatio(self, uniquenessRatio: int) -> None: ...


class Stitcher:
    @overload
    def composePanorama(self) -> Tuple[Mat, Mat]: ...
    @overload
    def composePanorama(self) -> Tuple[UMat, UMat]: ...
    @overload
    def composePanorama(self, images: Sequence[Mat]) -> Tuple[Mat, Mat]: ...
    @overload
    def composePanorama(self, images: Sequence[UMat]) -> Tuple[UMat, UMat]: ...
    def compositingResol(self) -> float: ...
    @staticmethod
    def create(mode: Mode = ...) -> Stitcher: ...
    @overload
    def estimateTransform(self, images: Sequence[Mat], masks: Sequence[Mat] = ...) -> Status: ...
    @overload
    def estimateTransform(self, images: Sequence[UMat], masks: Sequence[UMat] = ...) -> Status: ...
    def interpolationFlags(self) -> InterpolationFlags: ...
    def panoConfidenceThresh(self) -> float: ...
    def registrationResol(self) -> float: ...
    def seamEstimationResol(self) -> float: ...
    def setCompositingResol(self, resol_mpx: float) -> None: ...
    def setInterpolationFlags(self, interp_flags: InterpolationFlags) -> None: ...
    def setPanoConfidenceThresh(self, conf_thresh: float) -> None: ...
    def setRegistrationResol(self, resol_mpx: float) -> None: ...
    def setSeamEstimationResol(self, resol_mpx: float) -> None: ...
    def setWaveCorrection(self, flag: bool) -> None: ...
    @overload
    def stitch(self, images: Sequence[Mat]) -> Tuple[Mat, Mat]: ...
    @overload
    def stitch(self, images: Sequence[UMat]) -> Tuple[UMat, UMat]: ...
    @overload
    def stitch(self, images: Sequence[Mat], masks: Sequence[Mat]) -> Tuple[Mat, Mat]: ...
    @overload
    def stitch(self, images: Sequence[UMat], masks: Sequence[UMat]) -> Tuple[UMat, UMat]: ...
    def waveCorrection(self) -> bool: ...
    def workScale(self) -> float: ...


class Subdiv2D:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, rect: Rect) -> None: ...
    def edgeDst(self, edge: int) -> Tuple[Point2f, Point2f]: ...
    def edgeOrg(self, edge: int) -> Tuple[Point2f, Point2f]: ...
    def findNearest(self, pt: Point2f) -> Tuple[Point2f, Point2f]: ...
    def getEdge(self, edge: int, nextEdgeType: int) -> int: ...
    def getEdgeList(self) -> Sequence[Vec4f]: ...
    def getLeadingEdgeList(self) -> Sequence[int]: ...
    def getTriangleList(self) -> Sequence[Vec6f]: ...
    def getVertex(self, vertex: int) -> Tuple[int, int]: ...
    def getVoronoiFacetList(self, idx: Sequence[int]) -> Tuple[Sequence[Sequence[Point2f]], Sequence[Point2f]]: ...
    def initDelaunay(self, rect: Rect) -> None: ...
    @overload
    def insert(self, pt: Point2f) -> int: ...
    @overload
    def insert(self, ptvec: Sequence[Point2f]) -> None: ...
    def locate(self, pt: Point2f) -> Tuple[int, int, int]: ...
    def nextEdge(self, edge: int) -> int: ...
    def rotateEdge(self, edge: int, rotate: int) -> int: ...
    def symEdge(self, edge: int) -> int: ...


class TickMeter:
    def __init__(self) -> None: ...
    def getAvgTimeMilli(self) -> float: ...
    def getAvgTimeSec(self) -> float: ...
    def getCounter(self) -> int: ...
    def getFPS(self) -> float: ...
    def getTimeMicro(self) -> float: ...
    def getTimeMilli(self) -> float: ...
    def getTimeSec(self) -> float: ...
    def getTimeTicks(self) -> int: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...


class Tonemap:
    def getGamma(self) -> float: ...
    @overload
    def process(self, src: Mat) -> Mat: ...
    @overload
    def process(self, src: UMat) -> UMat: ...
    def setGamma(self, gamma: float) -> None: ...


class TonemapDrago:
    def getBias(self) -> float: ...
    def getSaturation(self) -> float: ...
    def setBias(self, bias: float) -> None: ...
    def setSaturation(self, saturation: float) -> None: ...


class TonemapMantiuk:
    def getSaturation(self) -> float: ...
    def getScale(self) -> float: ...
    def setSaturation(self, saturation: float) -> None: ...
    def setScale(self, scale: float) -> None: ...


class TonemapReinhard:
    def getColorAdaptation(self) -> float: ...
    def getIntensity(self) -> float: ...
    def getLightAdaptation(self) -> float: ...
    def setColorAdaptation(self, color_adapt: float) -> None: ...
    def setIntensity(self, intensity: float) -> None: ...
    def setLightAdaptation(self, light_adapt: float) -> None: ...


class Tracker:
    @overload
    def init(self, image: Mat, boundingBox: Rect) -> None: ...
    @overload
    def init(self, image: UMat, boundingBox: Rect) -> None: ...
    @overload
    def update(self, image: Mat) -> Tuple[Rect, Rect]: ...
    @overload
    def update(self, image: UMat) -> Tuple[Rect, Rect]: ...


class TrackerDaSiamRPN:
    @staticmethod
    def create(parameters: TrackerDaSiamRPN_Params = ...) -> TrackerDaSiamRPN: ...
    def getTrackingScore(self) -> float: ...


class TrackerDaSiamRPN_Params:
    backend: int
    kernel_cls1: str
    kernel_r1: str
    model: str
    target: int
    def __init__(self) -> None: ...


class TrackerGOTURN:
    @staticmethod
    def create(parameters: TrackerGOTURN_Params = ...) -> TrackerGOTURN: ...


class TrackerGOTURN_Params:
    modelBin: str
    modelTxt: str
    def __init__(self) -> None: ...


class TrackerMIL:
    @staticmethod
    def create(parameters: TrackerMIL_Params = ...) -> TrackerMIL: ...


class TrackerMIL_Params:
    featureSetNumFeatures: int
    samplerInitInRadius: float
    samplerInitMaxNegNum: int
    samplerSearchWinSize: float
    samplerTrackInRadius: float
    samplerTrackMaxNegNum: int
    samplerTrackMaxPosNum: int
    def __init__(self) -> None: ...


class UMat:
    offset: int
    @overload
    def __init__(self, usageFlags: UMatUsageFlags = ...) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int, type: int, usageFlags: UMatUsageFlags = ...) -> None: ...
    @overload
    def __init__(self, size: Size, type: int, usageFlags: UMatUsageFlags = ...) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int, type: int, s: Scalar, usageFlags: UMatUsageFlags = ...) -> None: ...
    @overload
    def __init__(self, size: Size, type: int, s: Scalar, usageFlags: UMatUsageFlags = ...) -> None: ...
    @overload
    def __init__(self, m: UMat) -> None: ...
    @overload
    def __init__(self, m: UMat, rowRange: Range, colRange: Range = ...) -> None: ...
    @overload
    def __init__(self, m: UMat, roi: Rect) -> None: ...
    @overload
    def __init__(self, m: UMat, ranges: Sequence[Range]) -> None: ...
    @staticmethod
    def context() -> None: ...
    def get(self) -> Mat: ...
    def handle(self, accessFlags: AccessFlag) -> None: ...
    def isContinuous(self) -> bool: ...
    def isSubmatrix(self) -> bool: ...
    @staticmethod
    def queue() -> None: ...


class UsacParams:
    confidence: float
    isParallel: bool
    loIterations: int
    loMethod: LocalOptimMethod
    loSampleSize: int
    maxIterations: int
    neighborsSearch: NeighborSearchMethod
    randomGeneratorState: int
    sampler: SamplingMethod
    score: ScoreMethod
    threshold: float
    def __init__(self) -> None: ...


class VariationalRefinement:
    @overload
    def calcUV(self, I0: Mat, I1: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def calcUV(self, I0: UMat, I1: UMat) -> Tuple[UMat, UMat]: ...
    @staticmethod
    def create() -> VariationalRefinement: ...
    def getAlpha(self) -> float: ...
    def getDelta(self) -> float: ...
    def getFixedPointIterations(self) -> int: ...
    def getGamma(self) -> float: ...
    def getOmega(self) -> float: ...
    def getSorIterations(self) -> int: ...
    def setAlpha(self, val: float) -> None: ...
    def setDelta(self, val: float) -> None: ...
    def setFixedPointIterations(self, val: int) -> None: ...
    def setGamma(self, val: float) -> None: ...
    def setOmega(self, val: float) -> None: ...
    def setSorIterations(self, val: int) -> None: ...


class VideoCapture:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, filename: str, apiPreference: int = ...) -> None: ...
    @overload
    def __init__(self, filename: str, apiPreference: int, params: Sequence[int]) -> None: ...
    @overload
    def __init__(self, index: int, apiPreference: int = ...) -> None: ...
    @overload
    def __init__(self, index: int, apiPreference: int, params: Sequence[int]) -> None: ...
    def get(self, propId: int) -> float: ...
    def getBackendName(self) -> str: ...
    def getExceptionMode(self) -> bool: ...
    def grab(self) -> bool: ...
    def isOpened(self) -> bool: ...
    @overload
    def open(self, filename: str, apiPreference: int = ...) -> bool: ...
    @overload
    def open(self, filename: str, apiPreference: int, params: Sequence[int]) -> bool: ...
    @overload
    def open(self, index: int, apiPreference: int = ...) -> bool: ...
    @overload
    def open(self, index: int, apiPreference: int, params: Sequence[int]) -> bool: ...
    @overload
    def read(self) -> Tuple[Mat, Mat]: ...
    @overload
    def read(self) -> Tuple[UMat, UMat]: ...
    def release(self) -> None: ...
    @overload
    def retrieve(self, flag: int = ...) -> Tuple[int, Mat]: ...
    @overload
    def retrieve(self, flag: int = ...) -> Tuple[int, UMat]: ...
    def set(self, propId: int, value: float) -> bool: ...
    def setExceptionMode(self, enable: bool) -> None: ...


class VideoWriter:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, filename: str, fourcc: int, fps: float, frameSize: Size, isColor: bool = ...) -> None: ...
    @overload
    def __init__(self, filename: str, apiPreference: int, fourcc: int, fps: float, frameSize: Size, isColor: bool = ...) -> None: ...
    @overload
    def __init__(self, filename: str, fourcc: int, fps: float, frameSize: Size, params: Sequence[int]) -> None: ...
    @overload
    def __init__(self, filename: str, apiPreference: int, fourcc: int, fps: float, frameSize: Size, params: Sequence[int]) -> None: ...
    @staticmethod
    def fourcc(c1: str, c2: str, c3: str, c4: str) -> int: ...
    def get(self, propId: int) -> float: ...
    def getBackendName(self) -> str: ...
    def isOpened(self) -> bool: ...
    @overload
    def open(self, filename: str, fourcc: int, fps: float, frameSize: Size, isColor: bool = ...) -> bool: ...
    @overload
    def open(self, filename: str, apiPreference: int, fourcc: int, fps: float, frameSize: Size, isColor: bool = ...) -> bool: ...
    @overload
    def open(self, filename: str, fourcc: int, fps: float, frameSize: Size, params: Sequence[int]) -> bool: ...
    @overload
    def open(self, filename: str, apiPreference: int, fourcc: int, fps: float, frameSize: Size, params: Sequence[int]) -> bool: ...
    def release(self) -> None: ...
    def set(self, propId: int, value: float) -> bool: ...
    @overload
    def write(self, image: Mat) -> None: ...
    @overload
    def write(self, image: UMat) -> None: ...


class WarperCreator:
    pass


class cuda_BufferPool:
    def getAllocator(self) -> GpuMat_Allocator: ...
    @overload
    def getBuffer(self, rows: int, cols: int, type: int) -> GpuMat: ...
    @overload
    def getBuffer(self, size: Size, type: int) -> GpuMat: ...


class cuda_DeviceInfo:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, device_id: int) -> None: ...
    def ECCEnabled(self) -> bool: ...
    def asyncEngineCount(self) -> int: ...
    def canMapHostMemory(self) -> bool: ...
    def clockRate(self) -> int: ...
    def computeMode(self) -> DeviceInfo_ComputeMode: ...
    def concurrentKernels(self) -> bool: ...
    def deviceID(self) -> int: ...
    def freeMemory(self) -> int: ...
    def integrated(self) -> bool: ...
    def isCompatible(self) -> bool: ...
    def kernelExecTimeoutEnabled(self) -> bool: ...
    def l2CacheSize(self) -> int: ...
    def majorVersion(self) -> int: ...
    def maxGridSize(self) -> Vec3i: ...
    def maxSurface1D(self) -> int: ...
    def maxSurface1DLayered(self) -> Vec2i: ...
    def maxSurface2D(self) -> Vec2i: ...
    def maxSurface2DLayered(self) -> Vec3i: ...
    def maxSurface3D(self) -> Vec3i: ...
    def maxSurfaceCubemap(self) -> int: ...
    def maxSurfaceCubemapLayered(self) -> Vec2i: ...
    def maxTexture1D(self) -> int: ...
    def maxTexture1DLayered(self) -> Vec2i: ...
    def maxTexture1DLinear(self) -> int: ...
    def maxTexture1DMipmap(self) -> int: ...
    def maxTexture2D(self) -> Vec2i: ...
    def maxTexture2DGather(self) -> Vec2i: ...
    def maxTexture2DLayered(self) -> Vec3i: ...
    def maxTexture2DLinear(self) -> Vec3i: ...
    def maxTexture2DMipmap(self) -> Vec2i: ...
    def maxTexture3D(self) -> Vec3i: ...
    def maxTextureCubemap(self) -> int: ...
    def maxTextureCubemapLayered(self) -> Vec2i: ...
    def maxThreadsDim(self) -> Vec3i: ...
    def maxThreadsPerBlock(self) -> int: ...
    def maxThreadsPerMultiProcessor(self) -> int: ...
    def memPitch(self) -> int: ...
    def memoryBusWidth(self) -> int: ...
    def memoryClockRate(self) -> int: ...
    def minorVersion(self) -> int: ...
    def multiProcessorCount(self) -> int: ...
    def pciBusID(self) -> int: ...
    def pciDeviceID(self) -> int: ...
    def pciDomainID(self) -> int: ...
    def queryMemory(self, totalMemory: int, freeMemory: int) -> None: ...
    def regsPerBlock(self) -> int: ...
    def sharedMemPerBlock(self) -> int: ...
    def surfaceAlignment(self) -> int: ...
    def tccDriver(self) -> bool: ...
    def textureAlignment(self) -> int: ...
    def texturePitchAlignment(self) -> int: ...
    def totalConstMem(self) -> int: ...
    def totalGlobalMem(self) -> int: ...
    def totalMemory(self) -> int: ...
    def unifiedAddressing(self) -> bool: ...
    def warpSize(self) -> int: ...


class cuda_Event:
    def __init__(self, flags: Event_CreateFlags = ...) -> None: ...
    @staticmethod
    def elapsedTime(start: Event, end: Event) -> float: ...
    def queryIfComplete(self) -> bool: ...
    def record(self, stream: Stream = ...) -> None: ...
    def waitForCompletion(self) -> None: ...


class cuda_GpuData:
    pass


class cuda_GpuMat:
    step: int
    @overload
    def __init__(self, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int, type: int, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, size: Size, type: int, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int, type: int, s: Scalar, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, size: Size, type: int, s: Scalar, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, m: GpuMat) -> None: ...
    @overload
    def __init__(self, m: GpuMat, rowRange: Range, colRange: Range) -> None: ...
    @overload
    def __init__(self, m: GpuMat, roi: Rect) -> None: ...
    @overload
    def __init__(self, arr: Mat, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, arr: GpuMat, allocator: GpuMat_Allocator = ...) -> None: ...
    @overload
    def __init__(self, arr: UMat, allocator: GpuMat_Allocator = ...) -> None: ...
    def adjustROI(self, dtop: int, dbottom: int, dleft: int, dright: int) -> GpuMat: ...
    def assignTo(self, m: GpuMat, type: int = ...) -> None: ...
    def channels(self) -> int: ...
    def clone(self) -> GpuMat: ...
    def col(self, x: int) -> GpuMat: ...
    @overload
    def colRange(self, startcol: int, endcol: int) -> GpuMat: ...
    @overload
    def colRange(self, r: Range) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int) -> Mat: ...
    @overload
    def convertTo(self, rtype: int) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int) -> UMat: ...
    @overload
    def convertTo(self, rtype: int, stream: Stream) -> Mat: ...
    @overload
    def convertTo(self, rtype: int, stream: Stream) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int, stream: Stream) -> UMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float = ...) -> Mat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float = ...) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float = ...) -> UMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, stream: Stream) -> Mat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, stream: Stream) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, stream: Stream) -> UMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float, stream: Stream) -> Mat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float, stream: Stream) -> GpuMat: ...
    @overload
    def convertTo(self, rtype: int, alpha: float, beta: float, stream: Stream) -> UMat: ...
    @overload
    def copyTo(self) -> Mat: ...
    @overload
    def copyTo(self) -> GpuMat: ...
    @overload
    def copyTo(self) -> UMat: ...
    @overload
    def copyTo(self, stream: Stream) -> Mat: ...
    @overload
    def copyTo(self, stream: Stream) -> GpuMat: ...
    @overload
    def copyTo(self, stream: Stream) -> UMat: ...
    @overload
    def copyTo(self, mask: Mat) -> Mat: ...
    @overload
    def copyTo(self, mask: GpuMat) -> GpuMat: ...
    @overload
    def copyTo(self, mask: UMat) -> UMat: ...
    @overload
    def copyTo(self, mask: Mat, stream: Stream) -> Mat: ...
    @overload
    def copyTo(self, mask: GpuMat, stream: Stream) -> GpuMat: ...
    @overload
    def copyTo(self, mask: UMat, stream: Stream) -> UMat: ...
    @overload
    def create(self, rows: int, cols: int, type: int) -> None: ...
    @overload
    def create(self, size: Size, type: int) -> None: ...
    def cudaPtr(self) -> None: ...
    @staticmethod
    def defaultAllocator() -> GpuMat_Allocator: ...
    def depth(self) -> int: ...
    @overload
    def download(self) -> Mat: ...
    @overload
    def download(self) -> GpuMat: ...
    @overload
    def download(self) -> UMat: ...
    @overload
    def download(self, stream: Stream) -> Mat: ...
    @overload
    def download(self, stream: Stream) -> GpuMat: ...
    @overload
    def download(self, stream: Stream) -> UMat: ...
    def elemSize(self) -> int: ...
    def elemSize1(self) -> int: ...
    def empty(self) -> bool: ...
    def isContinuous(self) -> bool: ...
    def locateROI(self, wholeSize: Size, ofs: Point) -> None: ...
    def reshape(self, cn: int, rows: int = ...) -> GpuMat: ...
    def row(self, y: int) -> GpuMat: ...
    @overload
    def rowRange(self, startrow: int, endrow: int) -> GpuMat: ...
    @overload
    def rowRange(self, r: Range) -> GpuMat: ...
    @staticmethod
    def setDefaultAllocator(allocator: GpuMat_Allocator) -> None: ...
    @overload
    def setTo(self, s: Scalar) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, stream: Stream) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: Mat) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: GpuMat) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: UMat) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: Mat, stream: Stream) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: GpuMat, stream: Stream) -> GpuMat: ...
    @overload
    def setTo(self, s: Scalar, mask: UMat, stream: Stream) -> GpuMat: ...
    def size(self) -> Size: ...
    def step1(self) -> int: ...
    def swap(self, mat: GpuMat) -> None: ...
    def type(self) -> int: ...
    def updateContinuityFlag(self) -> None: ...
    @overload
    def upload(self, arr: Mat) -> None: ...
    @overload
    def upload(self, arr: GpuMat) -> None: ...
    @overload
    def upload(self, arr: UMat) -> None: ...
    @overload
    def upload(self, arr: Mat, stream: Stream) -> None: ...
    @overload
    def upload(self, arr: GpuMat, stream: Stream) -> None: ...
    @overload
    def upload(self, arr: UMat, stream: Stream) -> None: ...


class cuda_GpuMatND:
    pass


class cuda_GpuMat_Allocator:
    pass


class cuda_HostMem:
    step: int
    @overload
    def __init__(self, alloc_type: HostMem_AllocType = ...) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int, type: int, alloc_type: HostMem_AllocType = ...) -> None: ...
    @overload
    def __init__(self, size: Size, type: int, alloc_type: HostMem_AllocType = ...) -> None: ...
    @overload
    def __init__(self, arr: Mat, alloc_type: HostMem_AllocType = ...) -> None: ...
    @overload
    def __init__(self, arr: GpuMat, alloc_type: HostMem_AllocType = ...) -> None: ...
    @overload
    def __init__(self, arr: UMat, alloc_type: HostMem_AllocType = ...) -> None: ...
    def channels(self) -> int: ...
    def clone(self) -> HostMem: ...
    def create(self, rows: int, cols: int, type: int) -> None: ...
    def createMatHeader(self) -> Mat: ...
    def depth(self) -> int: ...
    def elemSize(self) -> int: ...
    def elemSize1(self) -> int: ...
    def empty(self) -> bool: ...
    def isContinuous(self) -> bool: ...
    def reshape(self, cn: int, rows: int = ...) -> HostMem: ...
    def size(self) -> Size: ...
    def step1(self) -> int: ...
    def swap(self, b: HostMem) -> None: ...
    def type(self) -> int: ...


class cuda_Stream:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, allocator: GpuMat_Allocator) -> None: ...
    @overload
    def __init__(self, cudaFlags: int) -> None: ...
    @staticmethod
    def Null() -> Stream: ...
    def cudaPtr(self) -> None: ...
    def queryIfComplete(self) -> bool: ...
    def waitEvent(self, event: Event) -> None: ...
    def waitForCompletion(self) -> None: ...


class cuda_TargetArchs:
    @staticmethod
    def has(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasBin(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasEqualOrGreater(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasEqualOrGreaterBin(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasEqualOrGreaterPtx(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasEqualOrLessPtx(major: int, minor: int) -> bool: ...
    @staticmethod
    def hasPtx(major: int, minor: int) -> bool: ...


class detail_AffineBasedEstimator:
    pass


class detail_AffineBestOf2NearestMatcher:
    pass


class detail_BestOf2NearestMatcher:
    def __init__(self, try_use_gpu: bool = ..., match_conf: float = ..., num_matches_thresh1: int = ..., num_matches_thresh2: int = ...) -> None: ...
    def collectGarbage(self) -> None: ...
    @staticmethod
    def create(try_use_gpu: bool = ..., match_conf: float = ..., num_matches_thresh1: int = ..., num_matches_thresh2: int = ...) -> BestOf2NearestMatcher: ...


class detail_BestOf2NearestRangeMatcher:
    pass


class detail_Blender:
    @overload
    def blend(self) -> Tuple[Mat, Mat]: ...
    @overload
    def blend(self) -> Tuple[UMat, UMat]: ...
    @staticmethod
    def createDefault(type: int, try_gpu: bool = ...) -> Blender: ...
    @overload
    def feed(self, img: Mat, mask: Mat, tl: Point) -> None: ...
    @overload
    def feed(self, img: UMat, mask: UMat, tl: Point) -> None: ...
    @overload
    def prepare(self, corners: Sequence[Point], sizes: Sequence[Size]) -> None: ...
    @overload
    def prepare(self, dst_roi: Rect) -> None: ...


class detail_BlocksChannelsCompensator:
    pass


class detail_BlocksCompensator:
    @overload
    def apply(self, index: int, corner: Point, mask: Mat) -> Mat: ...
    @overload
    def apply(self, index: int, corner: Point, mask: UMat) -> UMat: ...
    def getBlockSize(self) -> Size: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    def getNrFeeds(self) -> int: ...
    def getNrGainsFilteringIterations(self) -> int: ...
    def getSimilarityThreshold(self) -> float: ...
    @overload
    def setBlockSize(self, width: int, height: int) -> None: ...
    @overload
    def setBlockSize(self, size: Size) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    def setNrFeeds(self, nr_feeds: int) -> None: ...
    def setNrGainsFilteringIterations(self, nr_iterations: int) -> None: ...
    def setSimilarityThreshold(self, similarity_threshold: float) -> None: ...


class detail_BlocksGainCompensator:
    @overload
    def __init__(self, bl_width: int = ..., bl_height: int = ...) -> None: ...
    @overload
    def __init__(self, bl_width: int, bl_height: int, nr_feeds: int) -> None: ...
    @overload
    def apply(self, index: int, corner: Point, mask: Mat) -> Mat: ...
    @overload
    def apply(self, index: int, corner: Point, mask: UMat) -> UMat: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...


class detail_BundleAdjusterAffine:
    pass


class detail_BundleAdjusterAffinePartial:
    pass


class detail_BundleAdjusterBase:
    def confThresh(self) -> float: ...
    def refinementMask(self) -> Mat: ...
    def setConfThresh(self, conf_thresh: float) -> None: ...
    @overload
    def setRefinementMask(self, mask: Mat) -> None: ...
    @overload
    def setRefinementMask(self, mask: Mat) -> None: ...
    def setTermCriteria(self, term_criteria: TermCriteria) -> None: ...
    def termCriteria(self) -> TermCriteria: ...


class detail_BundleAdjusterRay:
    pass


class detail_BundleAdjusterReproj:
    pass


class detail_CameraParams:
    R: Mat
    aspect: float
    focal: float
    ppx: float
    ppy: float
    t: Mat
    def K(self) -> Mat: ...


class detail_ChannelsCompensator:
    def __init__(self, nr_feeds: int = ...) -> None: ...
    @overload
    def apply(self, index: int, corner: Point, mask: Mat) -> Mat: ...
    @overload
    def apply(self, index: int, corner: Point, mask: UMat) -> UMat: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    def getNrFeeds(self) -> int: ...
    def getSimilarityThreshold(self) -> float: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    def setNrFeeds(self, nr_feeds: int) -> None: ...
    def setSimilarityThreshold(self, similarity_threshold: float) -> None: ...


class detail_DpSeamFinder:
    def __init__(self, costFunc: str) -> None: ...
    def setCostFunction(self, val: str) -> None: ...


class detail_Estimator:
    def apply(self, features: Sequence[ImageFeatures], pairwise_matches: Sequence[MatchesInfo]) -> Tuple[Sequence[CameraParams], Sequence[CameraParams]]: ...


class detail_ExposureCompensator:
    @overload
    def apply(self, index: int, corner: Point, mask: Mat) -> Mat: ...
    @overload
    def apply(self, index: int, corner: Point, mask: UMat) -> UMat: ...
    @staticmethod
    def createDefault(type: int) -> ExposureCompensator: ...
    def feed(self, corners: Sequence[Point], images: Sequence[UMat], masks: Sequence[UMat]) -> None: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    def getUpdateGain(self) -> bool: ...
    @overload
    def setMatGains(self, arg1: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, arg1: Sequence[Mat]) -> None: ...
    def setUpdateGain(self, b: bool) -> None: ...


class detail_ExtractArgsCallback:
    pass


class detail_ExtractMetaCallback:
    pass


class detail_FeatherBlender:
    def __init__(self, sharpness: float = ...) -> None: ...
    @overload
    def blend(self) -> Tuple[Mat, Mat]: ...
    @overload
    def blend(self) -> Tuple[UMat, UMat]: ...
    def createWeightMaps(self, masks: Sequence[UMat], corners: Sequence[Point]) -> Tuple[Sequence[UMat], Sequence[UMat]]: ...
    @overload
    def feed(self, img: Mat, mask: Mat, tl: Point) -> None: ...
    @overload
    def feed(self, img: UMat, mask: UMat, tl: Point) -> None: ...
    def prepare(self, dst_roi: Rect) -> None: ...
    def setSharpness(self, val: float) -> None: ...
    def sharpness(self) -> float: ...


class detail_FeaturesMatcher:
    def apply(self, features1: ImageFeatures, features2: ImageFeatures) -> MatchesInfo: ...
    def apply2(self, features: Sequence[ImageFeatures], mask: UMat = ...) -> Sequence[MatchesInfo]: ...
    def collectGarbage(self) -> None: ...
    def isThreadSafe(self) -> bool: ...


class detail_GainCompensator:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nr_feeds: int) -> None: ...
    @overload
    def apply(self, index: int, corner: Point, mask: Mat) -> Mat: ...
    @overload
    def apply(self, index: int, corner: Point, mask: UMat) -> UMat: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    def getNrFeeds(self) -> int: ...
    def getSimilarityThreshold(self) -> float: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    def setNrFeeds(self, nr_feeds: int) -> None: ...
    def setSimilarityThreshold(self, similarity_threshold: float) -> None: ...


class detail_GraphCutSeamFinder:
    def __init__(self, cost_type: str, terminal_cost: float = ..., bad_region_penalty: float = ...) -> None: ...
    def find(self, src: Sequence[UMat], corners: Sequence[Point], masks: Sequence[UMat]) -> None: ...


class detail_HomographyBasedEstimator:
    pass


class detail_ImageFeatures:
    descriptors: UMat
    img_idx: int
    img_size: Size
    def getKeypoints(self) -> Sequence[KeyPoint]: ...


class detail_MatchesInfo:
    H: Mat
    confidence: float
    dst_img_idx: int
    num_inliers: int
    src_img_idx: int
    def getInliers(self) -> np.ndarray: ...
    def getMatches(self) -> Sequence[DMatch]: ...


class detail_MultiBandBlender:
    def __init__(self, try_gpu: int = ..., num_bands: int = ..., weight_type: int = ...) -> None: ...
    @overload
    def blend(self) -> Tuple[Mat, Mat]: ...
    @overload
    def blend(self) -> Tuple[UMat, UMat]: ...
    @overload
    def feed(self, img: Mat, mask: Mat, tl: Point) -> None: ...
    @overload
    def feed(self, img: UMat, mask: UMat, tl: Point) -> None: ...
    def numBands(self) -> int: ...
    def prepare(self, dst_roi: Rect) -> None: ...
    def setNumBands(self, val: int) -> None: ...


class detail_NoBundleAdjuster:
    pass


class detail_NoExposureCompensator:
    @overload
    def apply(self, arg1: int, arg2: Point, arg4: Mat) -> Mat: ...
    @overload
    def apply(self, arg1: int, arg2: Point, arg4: UMat) -> UMat: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def getMatGains(self) -> Sequence[Mat]: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...
    @overload
    def setMatGains(self, umv: Sequence[Mat]) -> None: ...


class detail_NoSeamFinder:
    def find(self, arg1: Sequence[UMat], arg2: Sequence[Point]) -> Sequence[UMat]: ...


class detail_PairwiseSeamFinder:
    def find(self, src: Sequence[UMat], corners: Sequence[Point]) -> Sequence[UMat]: ...


class detail_ProjectorBase:
    pass


class detail_SeamFinder:
    @staticmethod
    def createDefault(type: int) -> SeamFinder: ...
    def find(self, src: Sequence[UMat], corners: Sequence[Point]) -> Sequence[UMat]: ...


class detail_SphericalProjector:
    def mapBackward(self, u: float, v: float, x: float, y: float) -> None: ...
    def mapForward(self, x: float, y: float, u: float, v: float) -> None: ...


class detail_Timelapser:
    @staticmethod
    def createDefault(type: int) -> Timelapser: ...
    def getDst(self) -> UMat: ...
    def initialize(self, corners: Sequence[Point], sizes: Sequence[Size]) -> None: ...
    @overload
    def process(self, img: Mat, mask: Mat, tl: Point) -> None: ...
    @overload
    def process(self, img: UMat, mask: UMat, tl: Point) -> None: ...


class detail_TimelapserCrop:
    pass


class detail_VoronoiSeamFinder:
    def find(self, src: Sequence[UMat], corners: Sequence[Point]) -> Sequence[UMat]: ...


class dnn_ClassificationModel:
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def classify(self, frame: Mat) -> Tuple[int, float]: ...
    @overload
    def classify(self, frame: UMat) -> Tuple[int, float]: ...


class dnn_DetectionModel:
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def detect(self, frame: Mat, confThreshold: float = ..., nmsThreshold: float = ...) -> Tuple[Sequence[int], Sequence[float], Sequence[Rect]]: ...
    @overload
    def detect(self, frame: UMat, confThreshold: float = ..., nmsThreshold: float = ...) -> Tuple[Sequence[int], Sequence[float], Sequence[Rect]]: ...
    def getNmsAcrossClasses(self) -> bool: ...
    def setNmsAcrossClasses(self, value: bool) -> DetectionModel: ...


class dnn_DictValue:
    @overload
    def __init__(self, i: int) -> None: ...
    @overload
    def __init__(self, p: float) -> None: ...
    @overload
    def __init__(self, s: str) -> None: ...
    def getIntValue(self, idx: int = ...) -> int: ...
    def getRealValue(self, idx: int = ...) -> float: ...
    def getStringValue(self, idx: int = ...) -> str: ...
    def isInt(self) -> bool: ...
    def isReal(self) -> bool: ...
    def isString(self) -> bool: ...


class dnn_KeypointsModel:
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def estimate(self, frame: Mat, thresh: float = ...) -> Sequence[Point2f]: ...
    @overload
    def estimate(self, frame: UMat, thresh: float = ...) -> Sequence[Point2f]: ...


class dnn_Layer:
    blobs: Sequence[Mat]
    name: str
    preferableTarget: int
    type: str
    @overload
    def finalize(self, inputs: Sequence[Mat]) -> Sequence[Mat]: ...
    @overload
    def finalize(self, inputs: Sequence[UMat]) -> Sequence[UMat]: ...
    def outputNameToIndex(self, outputName: str) -> int: ...
    @overload
    def run(self, inputs: Sequence[Mat]) -> Tuple[Sequence[Mat], Sequence[Mat]]: ...
    @overload
    def run(self, inputs: Sequence[Mat]) -> Tuple[Sequence[Mat], Sequence[Mat]]: ...


class dnn_Model:
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def predict(self, frame: Mat) -> Sequence[Mat]: ...
    @overload
    def predict(self, frame: UMat) -> Sequence[UMat]: ...
    def setInputCrop(self, crop: bool) -> Model: ...
    def setInputMean(self, mean: Scalar) -> Model: ...
    def setInputParams(self, scale: float = ..., size: Size = ..., mean: Scalar = ..., swapRB: bool = ..., crop: bool = ...) -> None: ...
    def setInputScale(self, scale: float) -> Model: ...
    @overload
    def setInputSize(self, size: Size) -> Model: ...
    @overload
    def setInputSize(self, width: int, height: int) -> Model: ...
    def setInputSwapRB(self, swapRB: bool) -> Model: ...
    def setPreferableBackend(self, backendId: dnn_Backend) -> Model: ...
    def setPreferableTarget(self, targetId: dnn_Target) -> Model: ...


class dnn_Net:
    def __init__(self) -> None: ...
    def connect(self, outPin: str, inpPin: str) -> None: ...
    def dump(self) -> str: ...
    def dumpToFile(self, path: str) -> None: ...
    def empty(self) -> bool: ...
    def enableFusion(self, fusion: bool) -> None: ...
    @overload
    def forward(self, outputName: str = ...) -> Mat: ...
    @overload
    def forward(self, outputName: str = ...) -> Sequence[Mat]: ...
    @overload
    def forward(self, outputName: str = ...) -> Sequence[UMat]: ...
    @overload
    def forward(self, outBlobNames: Sequence[str]) -> Sequence[Mat]: ...
    @overload
    def forward(self, outBlobNames: Sequence[str]) -> Sequence[UMat]: ...
    def forwardAndRetrieve(self, outBlobNames: Sequence[str]) -> Sequence[Sequence[Mat]]: ...
    def forwardAsync(self, outputName: str = ...) -> AsyncArray: ...
    @overload
    def getFLOPS(self, netInputShapes: Sequence[MatShape]) -> int: ...
    @overload
    def getFLOPS(self, netInputShape: MatShape) -> int: ...
    @overload
    def getFLOPS(self, layerId: int, netInputShapes: Sequence[MatShape]) -> int: ...
    @overload
    def getFLOPS(self, layerId: int, netInputShape: MatShape) -> int: ...
    def getLayer(self, layerId: LayerId) -> Layer: ...
    def getLayerId(self, layer: str) -> int: ...
    def getLayerNames(self) -> Sequence[str]: ...
    def getLayerTypes(self) -> Sequence[str]: ...
    def getLayersCount(self, layerType: str) -> int: ...
    @overload
    def getLayersShapes(self, netInputShapes: Sequence[MatShape]) -> Tuple[Sequence[int], Sequence[Sequence[MatShape]], Sequence[Sequence[MatShape]]]: ...
    @overload
    def getLayersShapes(self, netInputShape: MatShape) -> Tuple[Sequence[int], Sequence[Sequence[MatShape]], Sequence[Sequence[MatShape]]]: ...
    @overload
    def getMemoryConsumption(self, netInputShape: MatShape) -> Tuple[int, int]: ...
    @overload
    def getMemoryConsumption(self, layerId: int, netInputShapes: Sequence[MatShape]) -> Tuple[int, int]: ...
    @overload
    def getMemoryConsumption(self, layerId: int, netInputShape: MatShape) -> Tuple[int, int]: ...
    def getParam(self, layer: LayerId, numParam: int = ...) -> Mat: ...
    def getPerfProfile(self) -> Tuple[Sequence[float], Sequence[float]]: ...
    def getUnconnectedOutLayers(self) -> Sequence[int]: ...
    def getUnconnectedOutLayersNames(self) -> Sequence[str]: ...
    @overload
    @staticmethod
    def readFromModelOptimizer(xml: str, bin: str) -> Net: ...
    @overload
    @staticmethod
    def readFromModelOptimizer(bufferModelConfig: Sequence[uchar], bufferWeights: Sequence[uchar]) -> Net: ...
    def setHalideScheduler(self, scheduler: str) -> None: ...
    @overload
    def setInput(self, blob: Mat, name: str = ..., scalefactor: float = ..., mean: Scalar = ...) -> None: ...
    @overload
    def setInput(self, blob: UMat, name: str = ..., scalefactor: float = ..., mean: Scalar = ...) -> None: ...
    def setInputShape(self, inputName: str, shape: MatShape) -> None: ...
    def setInputsNames(self, inputBlobNames: Sequence[str]) -> None: ...
    @overload
    def setParam(self, layer: LayerId, numParam: int, blob: Mat) -> None: ...
    @overload
    def setParam(self, layer: LayerId, numParam: int, blob: Mat) -> None: ...
    def setPreferableBackend(self, backendId: int) -> None: ...
    def setPreferableTarget(self, targetId: int) -> None: ...


class dnn_SegmentationModel:
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def segment(self, frame: Mat) -> Mat: ...
    @overload
    def segment(self, frame: UMat) -> UMat: ...


class dnn_TextDetectionModel:
    @overload
    def detect(self, frame: Mat) -> Tuple[Sequence[Sequence[Point]], Sequence[float]]: ...
    @overload
    def detect(self, frame: UMat) -> Tuple[Sequence[Sequence[Point]], Sequence[float]]: ...
    @overload
    def detect(self, frame: Mat) -> Sequence[Sequence[Point]]: ...
    @overload
    def detect(self, frame: UMat) -> Sequence[Sequence[Point]]: ...
    @overload
    def detectTextRectangles(self, frame: Mat) -> Tuple[Sequence[RotatedRect], Sequence[float]]: ...
    @overload
    def detectTextRectangles(self, frame: UMat) -> Tuple[Sequence[RotatedRect], Sequence[float]]: ...
    @overload
    def detectTextRectangles(self, frame: Mat) -> Sequence[RotatedRect]: ...
    @overload
    def detectTextRectangles(self, frame: UMat) -> Sequence[RotatedRect]: ...


class dnn_TextDetectionModel_DB:
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    def getBinaryThreshold(self) -> float: ...
    def getMaxCandidates(self) -> int: ...
    def getPolygonThreshold(self) -> float: ...
    def getUnclipRatio(self) -> float: ...
    def setBinaryThreshold(self, binaryThreshold: float) -> TextDetectionModel_DB: ...
    def setMaxCandidates(self, maxCandidates: int) -> TextDetectionModel_DB: ...
    def setPolygonThreshold(self, polygonThreshold: float) -> TextDetectionModel_DB: ...
    def setUnclipRatio(self, unclipRatio: float) -> TextDetectionModel_DB: ...


class dnn_TextDetectionModel_EAST:
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    def getConfidenceThreshold(self) -> float: ...
    def getNMSThreshold(self) -> float: ...
    def setConfidenceThreshold(self, confThreshold: float) -> TextDetectionModel_EAST: ...
    def setNMSThreshold(self, nmsThreshold: float) -> TextDetectionModel_EAST: ...


class dnn_TextRecognitionModel:
    @overload
    def __init__(self, network: Net) -> None: ...
    @overload
    def __init__(self, model: str, config: str = ...) -> None: ...
    def getDecodeType(self) -> str: ...
    def getVocabulary(self) -> Sequence[std_string]: ...
    @overload
    def recognize(self, frame: Mat) -> str: ...
    @overload
    def recognize(self, frame: UMat) -> str: ...
    @overload
    def recognize(self, frame: Mat, roiRects: Sequence[Mat]) -> Sequence[str]: ...
    @overload
    def recognize(self, frame: UMat, roiRects: Sequence[UMat]) -> Sequence[str]: ...
    def setDecodeType(self, decodeType: str) -> TextRecognitionModel: ...
    def setVocabulary(self, vocabulary: Sequence[str]) -> TextRecognitionModel: ...


class flann_Index:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, features: Mat, params: IndexParams, distType: cvflann_flann_distance_t = ...) -> None: ...
    @overload
    def __init__(self, features: UMat, params: IndexParams, distType: cvflann_flann_distance_t = ...) -> None: ...
    @overload
    def build(self, features: Mat, params: IndexParams, distType: cvflann_flann_distance_t = ...) -> None: ...
    @overload
    def build(self, features: UMat, params: IndexParams, distType: cvflann_flann_distance_t = ...) -> None: ...
    def getAlgorithm(self) -> cvflann_flann_algorithm_t: ...
    def getDistance(self) -> cvflann_flann_distance_t: ...
    @overload
    def knnSearch(self, query: Mat, knn: int, params: SearchParams = ...) -> Tuple[Mat, Mat]: ...
    @overload
    def knnSearch(self, query: UMat, knn: int, params: SearchParams = ...) -> Tuple[UMat, UMat]: ...
    @overload
    def load(self, features: Mat, filename: str) -> bool: ...
    @overload
    def load(self, features: UMat, filename: str) -> bool: ...
    @overload
    def radiusSearch(self, query: Mat, radius: float, maxResults: int, params: SearchParams = ...) -> Tuple[SearchParams, Mat, Mat]: ...
    @overload
    def radiusSearch(self, query: UMat, radius: float, maxResults: int, params: SearchParams = ...) -> Tuple[SearchParams, UMat, UMat]: ...
    def release(self) -> None: ...
    def save(self, filename: str) -> None: ...


class gapi_GKernelPackage:
    pass


class gapi_GNetPackage:
    pass


class gapi_ie_PyParams:
    pass


class gapi_wip_GOutputs:
    def getGArray(self, type: gapi_ArgType) -> GArrayT: ...
    def getGMat(self) -> GMat: ...
    def getGOpaque(self, type: gapi_ArgType) -> GOpaqueT: ...
    def getGScalar(self) -> GScalar: ...


class gapi_wip_IStreamSource:
    pass


class ml_ANN_MLP:
    @staticmethod
    def create() -> ANN_MLP: ...
    def getAnnealCoolingRatio(self) -> float: ...
    def getAnnealFinalT(self) -> float: ...
    def getAnnealInitialT(self) -> float: ...
    def getAnnealItePerStep(self) -> int: ...
    def getBackpropMomentumScale(self) -> float: ...
    def getBackpropWeightScale(self) -> float: ...
    def getLayerSizes(self) -> Mat: ...
    def getRpropDW0(self) -> float: ...
    def getRpropDWMax(self) -> float: ...
    def getRpropDWMin(self) -> float: ...
    def getRpropDWMinus(self) -> float: ...
    def getRpropDWPlus(self) -> float: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getTrainMethod(self) -> int: ...
    def getWeights(self, layerIdx: int) -> Mat: ...
    @staticmethod
    def load(filepath: str) -> ANN_MLP: ...
    def setActivationFunction(self, type: int, param1: float = ..., param2: float = ...) -> None: ...
    def setAnnealCoolingRatio(self, val: float) -> None: ...
    def setAnnealFinalT(self, val: float) -> None: ...
    def setAnnealInitialT(self, val: float) -> None: ...
    def setAnnealItePerStep(self, val: int) -> None: ...
    def setBackpropMomentumScale(self, val: float) -> None: ...
    def setBackpropWeightScale(self, val: float) -> None: ...
    @overload
    def setLayerSizes(self, _layer_sizes: Mat) -> None: ...
    @overload
    def setLayerSizes(self, _layer_sizes: UMat) -> None: ...
    def setRpropDW0(self, val: float) -> None: ...
    def setRpropDWMax(self, val: float) -> None: ...
    def setRpropDWMin(self, val: float) -> None: ...
    def setRpropDWMinus(self, val: float) -> None: ...
    def setRpropDWPlus(self, val: float) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...
    def setTrainMethod(self, method: int, param1: float = ..., param2: float = ...) -> None: ...


class ml_Boost:
    @staticmethod
    def create() -> Boost: ...
    def getBoostType(self) -> int: ...
    def getWeakCount(self) -> int: ...
    def getWeightTrimRate(self) -> float: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> Boost: ...
    def setBoostType(self, val: int) -> None: ...
    def setWeakCount(self, val: int) -> None: ...
    def setWeightTrimRate(self, val: float) -> None: ...


class ml_DTrees:
    @staticmethod
    def create() -> DTrees: ...
    def getCVFolds(self) -> int: ...
    def getMaxCategories(self) -> int: ...
    def getMaxDepth(self) -> int: ...
    def getMinSampleCount(self) -> int: ...
    def getPriors(self) -> Mat: ...
    def getRegressionAccuracy(self) -> float: ...
    def getTruncatePrunedTree(self) -> bool: ...
    def getUse1SERule(self) -> bool: ...
    def getUseSurrogates(self) -> bool: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> DTrees: ...
    def setCVFolds(self, val: int) -> None: ...
    def setMaxCategories(self, val: int) -> None: ...
    def setMaxDepth(self, val: int) -> None: ...
    def setMinSampleCount(self, val: int) -> None: ...
    @overload
    def setPriors(self, val: Mat) -> None: ...
    @overload
    def setPriors(self, val: Mat) -> None: ...
    def setRegressionAccuracy(self, val: float) -> None: ...
    def setTruncatePrunedTree(self, val: bool) -> None: ...
    def setUse1SERule(self, val: bool) -> None: ...
    def setUseSurrogates(self, val: bool) -> None: ...


class ml_EM:
    @staticmethod
    def create() -> EM: ...
    def getClustersNumber(self) -> int: ...
    def getCovarianceMatrixType(self) -> int: ...
    @overload
    def getCovs(self) -> Sequence[Mat]: ...
    @overload
    def getCovs(self) -> Sequence[Mat]: ...
    def getMeans(self) -> Mat: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getWeights(self) -> Mat: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> EM: ...
    @overload
    def predict(self, samples: Mat, flags: int = ...) -> Tuple[int, Mat]: ...
    @overload
    def predict(self, samples: UMat, flags: int = ...) -> Tuple[int, UMat]: ...
    @overload
    def predict2(self, sample: Mat) -> Tuple[Mat, Mat]: ...
    @overload
    def predict2(self, sample: UMat) -> Tuple[UMat, UMat]: ...
    def setClustersNumber(self, val: int) -> None: ...
    def setCovarianceMatrixType(self, val: int) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...
    @overload
    def trainE(self, samples: Mat, means0: Mat, covs0: Mat = ..., weights0: Mat = ...) -> Tuple[Mat, Mat, Mat, Mat]: ...
    @overload
    def trainE(self, samples: UMat, means0: UMat, covs0: UMat = ..., weights0: UMat = ...) -> Tuple[UMat, UMat, UMat, UMat]: ...
    @overload
    def trainEM(self, samples: Mat) -> Tuple[Mat, Mat, Mat, Mat]: ...
    @overload
    def trainEM(self, samples: UMat) -> Tuple[UMat, UMat, UMat, UMat]: ...
    @overload
    def trainM(self, samples: Mat, probs0: Mat) -> Tuple[Mat, Mat, Mat, Mat]: ...
    @overload
    def trainM(self, samples: UMat, probs0: UMat) -> Tuple[UMat, UMat, UMat, UMat]: ...


class ml_KNearest:
    @staticmethod
    def create() -> KNearest: ...
    @overload
    def findNearest(self, samples: Mat, k: int) -> Tuple[Mat, Mat, Mat, Mat]: ...
    @overload
    def findNearest(self, samples: UMat, k: int) -> Tuple[UMat, UMat, UMat, UMat]: ...
    def getAlgorithmType(self) -> int: ...
    def getDefaultK(self) -> int: ...
    def getEmax(self) -> int: ...
    def getIsClassifier(self) -> bool: ...
    @staticmethod
    def load(filepath: str) -> KNearest: ...
    def setAlgorithmType(self, val: int) -> None: ...
    def setDefaultK(self, val: int) -> None: ...
    def setEmax(self, val: int) -> None: ...
    def setIsClassifier(self, val: bool) -> None: ...


class ml_LogisticRegression:
    @staticmethod
    def create() -> LogisticRegression: ...
    def getIterations(self) -> int: ...
    def getLearningRate(self) -> float: ...
    def getMiniBatchSize(self) -> int: ...
    def getRegularization(self) -> int: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getTrainMethod(self) -> int: ...
    def get_learnt_thetas(self) -> Mat: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> LogisticRegression: ...
    @overload
    def predict(self, samples: Mat, flags: int = ...) -> Tuple[int, Mat]: ...
    @overload
    def predict(self, samples: UMat, flags: int = ...) -> Tuple[int, UMat]: ...
    def setIterations(self, val: int) -> None: ...
    def setLearningRate(self, val: float) -> None: ...
    def setMiniBatchSize(self, val: int) -> None: ...
    def setRegularization(self, val: int) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...
    def setTrainMethod(self, val: int) -> None: ...


class ml_NormalBayesClassifier:
    @staticmethod
    def create() -> NormalBayesClassifier: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> NormalBayesClassifier: ...
    @overload
    def predictProb(self, inputs: Mat, flags: int = ...) -> Tuple[int, Mat, Mat]: ...
    @overload
    def predictProb(self, inputs: UMat, flags: int = ...) -> Tuple[int, UMat, UMat]: ...


class ml_ParamGrid:
    logStep: float
    maxVal: float
    minVal: float
    @staticmethod
    def create(minVal: float = ..., maxVal: float = ..., logstep: float = ...) -> ParamGrid: ...


class ml_RTrees:
    @staticmethod
    def create() -> RTrees: ...
    def getActiveVarCount(self) -> int: ...
    def getCalculateVarImportance(self) -> bool: ...
    def getOOBError(self) -> float: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getVarImportance(self) -> Mat: ...
    @overload
    def getVotes(self, samples: Mat, flags: int) -> Mat: ...
    @overload
    def getVotes(self, samples: UMat, flags: int) -> UMat: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> RTrees: ...
    def setActiveVarCount(self, val: int) -> None: ...
    def setCalculateVarImportance(self, val: bool) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...


class ml_SVM:
    @staticmethod
    def create() -> SVM: ...
    def getC(self) -> float: ...
    def getClassWeights(self) -> Mat: ...
    def getCoef0(self) -> float: ...
    @overload
    def getDecisionFunction(self, i: int) -> Tuple[Mat, Mat, Mat]: ...
    @overload
    def getDecisionFunction(self, i: int) -> Tuple[UMat, UMat, UMat]: ...
    @staticmethod
    def getDefaultGridPtr(param_id: int) -> ParamGrid: ...
    def getDegree(self) -> float: ...
    def getGamma(self) -> float: ...
    def getKernelType(self) -> int: ...
    def getNu(self) -> float: ...
    def getP(self) -> float: ...
    def getSupportVectors(self) -> Mat: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getType(self) -> int: ...
    def getUncompressedSupportVectors(self) -> Mat: ...
    @staticmethod
    def load(filepath: str) -> SVM: ...
    def setC(self, val: float) -> None: ...
    @overload
    def setClassWeights(self, val: Mat) -> None: ...
    @overload
    def setClassWeights(self, val: Mat) -> None: ...
    def setCoef0(self, val: float) -> None: ...
    def setDegree(self, val: float) -> None: ...
    def setGamma(self, val: float) -> None: ...
    def setKernel(self, kernelType: int) -> None: ...
    def setNu(self, val: float) -> None: ...
    def setP(self, val: float) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...
    def setType(self, val: int) -> None: ...
    @overload
    def trainAuto(self, samples: Mat, layout: int, responses: Mat, kFold: int = ..., Cgrid: ParamGrid = ..., gammaGrid: ParamGrid = ..., pGrid: ParamGrid = ..., nuGrid: ParamGrid = ..., coeffGrid: ParamGrid = ..., degreeGrid: ParamGrid = ..., balanced: bool = ...) -> bool: ...
    @overload
    def trainAuto(self, samples: UMat, layout: int, responses: UMat, kFold: int = ..., Cgrid: ParamGrid = ..., gammaGrid: ParamGrid = ..., pGrid: ParamGrid = ..., nuGrid: ParamGrid = ..., coeffGrid: ParamGrid = ..., degreeGrid: ParamGrid = ..., balanced: bool = ...) -> bool: ...


class ml_SVMSGD:
    @staticmethod
    def create() -> SVMSGD: ...
    def getInitialStepSize(self) -> float: ...
    def getMarginRegularization(self) -> float: ...
    def getMarginType(self) -> int: ...
    def getShift(self) -> float: ...
    def getStepDecreasingPower(self) -> float: ...
    def getSvmsgdType(self) -> int: ...
    def getTermCriteria(self) -> TermCriteria: ...
    def getWeights(self) -> Mat: ...
    @staticmethod
    def load(filepath: str, nodeName: str = ...) -> SVMSGD: ...
    def setInitialStepSize(self, InitialStepSize: float) -> None: ...
    def setMarginRegularization(self, marginRegularization: float) -> None: ...
    def setMarginType(self, marginType: int) -> None: ...
    def setOptimalParameters(self, svmsgdType: int = ..., marginType: int = ...) -> None: ...
    def setStepDecreasingPower(self, stepDecreasingPower: float) -> None: ...
    def setSvmsgdType(self, svmsgdType: int) -> None: ...
    def setTermCriteria(self, val: TermCriteria) -> None: ...


class ml_StatModel:
    @overload
    def calcError(self, data: TrainData, test: bool) -> Tuple[Mat, Mat]: ...
    @overload
    def calcError(self, data: TrainData, test: bool) -> Tuple[UMat, UMat]: ...
    def empty(self) -> bool: ...
    def getVarCount(self) -> int: ...
    def isClassifier(self) -> bool: ...
    def isTrained(self) -> bool: ...
    @overload
    def predict(self, samples: Mat, flags: int = ...) -> Tuple[int, Mat]: ...
    @overload
    def predict(self, samples: UMat, flags: int = ...) -> Tuple[int, UMat]: ...
    @overload
    def train(self, trainData: TrainData, flags: int = ...) -> bool: ...
    @overload
    def train(self, samples: Mat, layout: int, responses: Mat) -> bool: ...
    @overload
    def train(self, samples: UMat, layout: int, responses: UMat) -> bool: ...


class ml_TrainData:
    @overload
    @staticmethod
    def create(samples: Mat, layout: int, responses: Mat, varIdx: Mat = ..., sampleIdx: Mat = ..., sampleWeights: Mat = ..., varType: Mat = ...) -> TrainData: ...
    @overload
    @staticmethod
    def create(samples: UMat, layout: int, responses: UMat, varIdx: UMat = ..., sampleIdx: UMat = ..., sampleWeights: UMat = ..., varType: UMat = ...) -> TrainData: ...
    def getCatCount(self, vi: int) -> int: ...
    def getCatMap(self) -> Mat: ...
    def getCatOfs(self) -> Mat: ...
    def getClassLabels(self) -> Mat: ...
    def getDefaultSubstValues(self) -> Mat: ...
    def getLayout(self) -> int: ...
    def getMissing(self) -> Mat: ...
    def getNAllVars(self) -> int: ...
    def getNSamples(self) -> int: ...
    def getNTestSamples(self) -> int: ...
    def getNTrainSamples(self) -> int: ...
    def getNVars(self) -> int: ...
    def getNames(self, names: Sequence[str]) -> None: ...
    def getNormCatResponses(self) -> Mat: ...
    def getResponseType(self) -> int: ...
    def getResponses(self) -> Mat: ...
    @overload
    def getSample(self, varIdx: Mat, sidx: int, buf: float) -> None: ...
    @overload
    def getSample(self, varIdx: UMat, sidx: int, buf: float) -> None: ...
    def getSampleWeights(self) -> Mat: ...
    def getSamples(self) -> Mat: ...
    @overload
    @staticmethod
    def getSubMatrix(matrix: Mat, idx: Mat, layout: int) -> Mat: ...
    @overload
    @staticmethod
    def getSubMatrix(matrix: Mat, idx: Mat, layout: int) -> Mat: ...
    @overload
    @staticmethod
    def getSubVector(vec: Mat, idx: Mat) -> Mat: ...
    @overload
    @staticmethod
    def getSubVector(vec: Mat, idx: Mat) -> Mat: ...
    def getTestNormCatResponses(self) -> Mat: ...
    def getTestResponses(self) -> Mat: ...
    def getTestSampleIdx(self) -> Mat: ...
    def getTestSampleWeights(self) -> Mat: ...
    def getTestSamples(self) -> Mat: ...
    def getTrainNormCatResponses(self) -> Mat: ...
    def getTrainResponses(self) -> Mat: ...
    def getTrainSampleIdx(self) -> Mat: ...
    def getTrainSampleWeights(self) -> Mat: ...
    def getTrainSamples(self, layout: int = ..., compressSamples: bool = ..., compressVars: bool = ...) -> Mat: ...
    @overload
    def getValues(self, vi: int, sidx: Mat, values: float) -> None: ...
    @overload
    def getValues(self, vi: int, sidx: UMat, values: float) -> None: ...
    def getVarIdx(self) -> Mat: ...
    def getVarSymbolFlags(self) -> Mat: ...
    def getVarType(self) -> Mat: ...
    def setTrainTestSplit(self, count: int, shuffle: bool = ...) -> None: ...
    def setTrainTestSplitRatio(self, ratio: float, shuffle: bool = ...) -> None: ...
    def shuffleTrainTest(self) -> None: ...


class ocl_Device:
    def __init__(self) -> None: ...
    def OpenCLVersion(self) -> str: ...
    def OpenCL_C_Version(self) -> str: ...
    def addressBits(self) -> int: ...
    def available(self) -> bool: ...
    def compilerAvailable(self) -> bool: ...
    def deviceVersionMajor(self) -> int: ...
    def deviceVersionMinor(self) -> int: ...
    def doubleFPConfig(self) -> int: ...
    def driverVersion(self) -> str: ...
    def endianLittle(self) -> bool: ...
    def errorCorrectionSupport(self) -> bool: ...
    def executionCapabilities(self) -> int: ...
    def extensions(self) -> str: ...
    @staticmethod
    def getDefault() -> Device: ...
    def globalMemCacheLineSize(self) -> int: ...
    def globalMemCacheSize(self) -> int: ...
    def globalMemCacheType(self) -> int: ...
    def globalMemSize(self) -> int: ...
    def halfFPConfig(self) -> int: ...
    def hostUnifiedMemory(self) -> bool: ...
    def image2DMaxHeight(self) -> int: ...
    def image2DMaxWidth(self) -> int: ...
    def image3DMaxDepth(self) -> int: ...
    def image3DMaxHeight(self) -> int: ...
    def image3DMaxWidth(self) -> int: ...
    def imageFromBufferSupport(self) -> bool: ...
    def imageMaxArraySize(self) -> int: ...
    def imageMaxBufferSize(self) -> int: ...
    def imageSupport(self) -> bool: ...
    def intelSubgroupsSupport(self) -> bool: ...
    def isAMD(self) -> bool: ...
    def isExtensionSupported(self, extensionName: str) -> bool: ...
    def isIntel(self) -> bool: ...
    def isNVidia(self) -> bool: ...
    def linkerAvailable(self) -> bool: ...
    def localMemSize(self) -> int: ...
    def localMemType(self) -> int: ...
    def maxClockFrequency(self) -> int: ...
    def maxComputeUnits(self) -> int: ...
    def maxConstantArgs(self) -> int: ...
    def maxConstantBufferSize(self) -> int: ...
    def maxMemAllocSize(self) -> int: ...
    def maxParameterSize(self) -> int: ...
    def maxReadImageArgs(self) -> int: ...
    def maxSamplers(self) -> int: ...
    def maxWorkGroupSize(self) -> int: ...
    def maxWorkItemDims(self) -> int: ...
    def maxWriteImageArgs(self) -> int: ...
    def memBaseAddrAlign(self) -> int: ...
    def name(self) -> str: ...
    def nativeVectorWidthChar(self) -> int: ...
    def nativeVectorWidthDouble(self) -> int: ...
    def nativeVectorWidthFloat(self) -> int: ...
    def nativeVectorWidthHalf(self) -> int: ...
    def nativeVectorWidthInt(self) -> int: ...
    def nativeVectorWidthLong(self) -> int: ...
    def nativeVectorWidthShort(self) -> int: ...
    def preferredVectorWidthChar(self) -> int: ...
    def preferredVectorWidthDouble(self) -> int: ...
    def preferredVectorWidthFloat(self) -> int: ...
    def preferredVectorWidthHalf(self) -> int: ...
    def preferredVectorWidthInt(self) -> int: ...
    def preferredVectorWidthLong(self) -> int: ...
    def preferredVectorWidthShort(self) -> int: ...
    def printfBufferSize(self) -> int: ...
    def profilingTimerResolution(self) -> int: ...
    def singleFPConfig(self) -> int: ...
    def type(self) -> int: ...
    def vendorID(self) -> int: ...
    def vendorName(self) -> str: ...
    def version(self) -> str: ...


class ocl_OpenCLExecutionContext:
    pass


class segmentation_IntelligentScissorsMB:
    def __init__(self) -> None: ...
    @overload
    def applyImage(self, image: Mat) -> IntelligentScissorsMB: ...
    @overload
    def applyImage(self, image: UMat) -> IntelligentScissorsMB: ...
    @overload
    def applyImageFeatures(self, non_edge: Mat, gradient_direction: Mat, gradient_magnitude: Mat, image: Mat = ...) -> IntelligentScissorsMB: ...
    @overload
    def applyImageFeatures(self, non_edge: UMat, gradient_direction: UMat, gradient_magnitude: UMat, image: UMat = ...) -> IntelligentScissorsMB: ...
    def buildMap(self, sourcePt: Point) -> None: ...
    @overload
    def getContour(self, targetPt: Point, backward: bool = ...) -> Mat: ...
    @overload
    def getContour(self, targetPt: Point, backward: bool = ...) -> UMat: ...
    def setEdgeFeatureCannyParameters(self, threshold1: float, threshold2: float, apertureSize: int = ..., L2gradient: bool = ...) -> IntelligentScissorsMB: ...
    def setEdgeFeatureZeroCrossingParameters(self, gradient_magnitude_min_value: float = ...) -> IntelligentScissorsMB: ...
    def setGradientMagnitudeMaxLimit(self, gradient_magnitude_threshold_max: float = ...) -> IntelligentScissorsMB: ...
    def setWeights(self, weight_non_edge: float, weight_gradient_direction: float, weight_gradient_magnitude: float) -> IntelligentScissorsMB: ...


def AKAZE_create(descriptor_type: AKAZE_DescriptorType = ..., descriptor_size: int = ..., descriptor_channels: int = ..., threshold: float = ..., nOctaves: int = ..., nOctaveLayers: int = ..., diffusivity: KAZE_DiffusivityType = ...) -> AKAZE: ...
def AffineFeature_create(backend: Feature2D, maxTilt: int = ..., minTilt: int = ..., tiltStep: float = ..., rotateStepBase: float = ...) -> AffineFeature: ...
def AgastFeatureDetector_create(threshold: int = ..., nonmaxSuppression: bool = ..., type: AgastFeatureDetector_DetectorType = ...) -> AgastFeatureDetector: ...
def BFMatcher_create(normType: int = ..., crossCheck: bool = ...) -> BFMatcher: ...
@overload
def BRISK_create(thresh: int = ..., octaves: int = ..., patternScale: float = ...) -> BRISK: ...
@overload
def BRISK_create(radiusList: Sequence[float], numberList: Sequence[int], dMax: float = ..., dMin: float = ..., indexChange: Sequence[int] = ...) -> BRISK: ...
@overload
def BRISK_create(thresh: int, octaves: int, radiusList: Sequence[float], numberList: Sequence[int], dMax: float = ..., dMin: float = ..., indexChange: Sequence[int] = ...) -> BRISK: ...
@overload
def CamShift(probImage: Mat, criteria: TermCriteria) -> Tuple[TermCriteria, Rect]: ...
@overload
def CamShift(probImage: UMat, criteria: TermCriteria) -> Tuple[TermCriteria, Rect]: ...
@overload
def Canny(image: Mat, threshold1: float, threshold2: float, apertureSize: int = ..., L2gradient: bool = ...) -> Mat: ...
@overload
def Canny(image: UMat, threshold1: float, threshold2: float, apertureSize: int = ..., L2gradient: bool = ...) -> UMat: ...
@overload
def Canny(dx: Mat, dy: Mat, threshold1: float, threshold2: float, L2gradient: bool = ...) -> Mat: ...
@overload
def Canny(dx: UMat, dy: UMat, threshold1: float, threshold2: float, L2gradient: bool = ...) -> UMat: ...
def CascadeClassifier_convert(oldcascade: str, newcascade: str) -> bool: ...
def DISOpticalFlow_create(preset: int = ...) -> DISOpticalFlow: ...
@overload
def DescriptorMatcher_create(descriptorMatcherType: str) -> DescriptorMatcher: ...
@overload
def DescriptorMatcher_create(matcherType: DescriptorMatcher_MatcherType) -> DescriptorMatcher: ...
@overload
def EMD(signature1: Mat, signature2: Mat, distType: int, cost: Mat = ...) -> Tuple[Mat, float, Mat]: ...
@overload
def EMD(signature1: UMat, signature2: UMat, distType: int, cost: UMat = ...) -> Tuple[UMat, float, UMat]: ...
def FarnebackOpticalFlow_create(numLevels: int = ..., pyrScale: float = ..., fastPyramids: bool = ..., winSize: int = ..., numIters: int = ..., polyN: int = ..., polySigma: float = ..., flags: int = ...) -> FarnebackOpticalFlow: ...
def FastFeatureDetector_create(threshold: int = ..., nonmaxSuppression: bool = ..., type: FastFeatureDetector_DetectorType = ...) -> FastFeatureDetector: ...
def FlannBasedMatcher_create() -> FlannBasedMatcher: ...
@overload
def GFTTDetector_create(maxCorners: int = ..., qualityLevel: float = ..., minDistance: float = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> GFTTDetector: ...
@overload
def GFTTDetector_create(maxCorners: int, qualityLevel: float, minDistance: float, blockSize: int, gradiantSize: int, useHarrisDetector: bool = ..., k: float = ...) -> GFTTDetector: ...
@overload
def GaussianBlur(src: Mat, ksize: Size, sigmaX: float, sigmaY: float = ..., borderType: int = ...) -> Mat: ...
@overload
def GaussianBlur(src: UMat, ksize: Size, sigmaX: float, sigmaY: float = ..., borderType: int = ...) -> UMat: ...
def HOGDescriptor_getDaimlerPeopleDetector() -> Sequence[float]: ...
def HOGDescriptor_getDefaultPeopleDetector() -> Sequence[float]: ...
@overload
def HoughCircles(image: Mat, method: int, dp: float, minDist: float, param1: float = ..., param2: float = ..., minRadius: int = ..., maxRadius: int = ...) -> Mat: ...
@overload
def HoughCircles(image: UMat, method: int, dp: float, minDist: float, param1: float = ..., param2: float = ..., minRadius: int = ..., maxRadius: int = ...) -> UMat: ...
@overload
def HoughLines(image: Mat, rho: float, theta: float, threshold: int, srn: float = ..., stn: float = ..., min_theta: float = ..., max_theta: float = ...) -> Mat: ...
@overload
def HoughLines(image: UMat, rho: float, theta: float, threshold: int, srn: float = ..., stn: float = ..., min_theta: float = ..., max_theta: float = ...) -> UMat: ...
@overload
def HoughLinesP(image: Mat, rho: float, theta: float, threshold: int, minLineLength: float = ..., maxLineGap: float = ...) -> Mat: ...
@overload
def HoughLinesP(image: UMat, rho: float, theta: float, threshold: int, minLineLength: float = ..., maxLineGap: float = ...) -> UMat: ...
@overload
def HoughLinesPointSet(point: Mat, lines_max: int, threshold: int, min_rho: float, max_rho: float, rho_step: float, min_theta: float, max_theta: float, theta_step: float) -> Mat: ...
@overload
def HoughLinesPointSet(point: UMat, lines_max: int, threshold: int, min_rho: float, max_rho: float, rho_step: float, min_theta: float, max_theta: float, theta_step: float) -> UMat: ...
@overload
def HoughLinesWithAccumulator(image: Mat, rho: float, theta: float, threshold: int, srn: float = ..., stn: float = ..., min_theta: float = ..., max_theta: float = ...) -> Mat: ...
@overload
def HoughLinesWithAccumulator(image: UMat, rho: float, theta: float, threshold: int, srn: float = ..., stn: float = ..., min_theta: float = ..., max_theta: float = ...) -> UMat: ...
@overload
def HuMoments(m: Moments) -> Mat: ...
@overload
def HuMoments(m: Moments) -> UMat: ...
def KAZE_create(extended: bool = ..., upright: bool = ..., threshold: float = ..., nOctaves: int = ..., nOctaveLayers: int = ..., diffusivity: KAZE_DiffusivityType = ...) -> KAZE: ...
@overload
def KeyPoint_convert(keypoints: Sequence[KeyPoint], keypointIndexes: Sequence[int] = ...) -> Sequence[Point2f]: ...
@overload
def KeyPoint_convert(points2f: Sequence[Point2f], size: float = ..., response: float = ..., octave: int = ..., class_id: int = ...) -> Sequence[KeyPoint]: ...
def KeyPoint_overlap(kp1: KeyPoint, kp2: KeyPoint) -> float: ...
@overload
def LUT(src: Mat, lut: Mat) -> Mat: ...
@overload
def LUT(src: UMat, lut: UMat) -> UMat: ...
@overload
def Laplacian(src: Mat, ddepth: int, ksize: int = ..., scale: float = ..., delta: float = ..., borderType: int = ...) -> Mat: ...
@overload
def Laplacian(src: UMat, ddepth: int, ksize: int = ..., scale: float = ..., delta: float = ..., borderType: int = ...) -> UMat: ...
def MSER_create(delta: int = ..., min_area: int = ..., max_area: int = ..., max_variation: float = ..., min_diversity: float = ..., max_evolution: int = ..., area_threshold: float = ..., min_margin: float = ..., edge_blur_size: int = ...) -> MSER: ...
@overload
def Mahalanobis(v1: Mat, v2: Mat, icovar: Mat) -> float: ...
@overload
def Mahalanobis(v1: UMat, v2: UMat, icovar: UMat) -> float: ...
def ORB_create(nfeatures: int = ..., scaleFactor: float = ..., nlevels: int = ..., edgeThreshold: int = ..., firstLevel: int = ..., WTA_K: int = ..., scoreType: ORB_ScoreType = ..., patchSize: int = ..., fastThreshold: int = ...) -> ORB: ...
@overload
def PCABackProject(data: Mat, mean: Mat, eigenvectors: Mat) -> Mat: ...
@overload
def PCABackProject(data: UMat, mean: UMat, eigenvectors: UMat) -> UMat: ...
@overload
def PCACompute(data: Mat, maxComponents: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def PCACompute(data: UMat, maxComponents: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def PCACompute(data: Mat, retainedVariance: float) -> Tuple[Mat, Mat]: ...
@overload
def PCACompute(data: UMat, retainedVariance: float) -> Tuple[UMat, UMat]: ...
@overload
def PCACompute2(data: Mat, maxComponents: int = ...) -> Tuple[Mat, Mat, Mat]: ...
@overload
def PCACompute2(data: UMat, maxComponents: int = ...) -> Tuple[UMat, UMat, UMat]: ...
@overload
def PCACompute2(data: Mat, retainedVariance: float) -> Tuple[Mat, Mat, Mat]: ...
@overload
def PCACompute2(data: UMat, retainedVariance: float) -> Tuple[UMat, UMat, UMat]: ...
@overload
def PCAProject(data: Mat, mean: Mat, eigenvectors: Mat) -> Mat: ...
@overload
def PCAProject(data: UMat, mean: UMat, eigenvectors: UMat) -> UMat: ...
@overload
def PSNR(src1: Mat, src2: Mat, R: float = ...) -> float: ...
@overload
def PSNR(src1: UMat, src2: UMat, R: float = ...) -> float: ...
@overload
def RQDecomp3x3(src: Mat) -> Tuple[Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def RQDecomp3x3(src: UMat) -> Tuple[UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def Rodrigues(src: Mat) -> Tuple[Mat, Mat]: ...
@overload
def Rodrigues(src: UMat) -> Tuple[UMat, UMat]: ...
@overload
def SIFT_create(nfeatures: int = ..., nOctaveLayers: int = ..., contrastThreshold: float = ..., edgeThreshold: float = ..., sigma: float = ...) -> SIFT: ...
@overload
def SIFT_create(nfeatures: int, nOctaveLayers: int, contrastThreshold: float, edgeThreshold: float, sigma: float, descriptorType: int) -> SIFT: ...
@overload
def SVBackSubst(w: Mat, u: Mat, vt: Mat, rhs: Mat) -> Mat: ...
@overload
def SVBackSubst(w: UMat, u: UMat, vt: UMat, rhs: UMat) -> UMat: ...
@overload
def SVDecomp(src: Mat, flags: int = ...) -> Tuple[Mat, Mat, Mat]: ...
@overload
def SVDecomp(src: UMat, flags: int = ...) -> Tuple[UMat, UMat, UMat]: ...
@overload
def Scharr(src: Mat, ddepth: int, dx: int, dy: int, scale: float = ..., delta: float = ..., borderType: int = ...) -> Mat: ...
@overload
def Scharr(src: UMat, ddepth: int, dx: int, dy: int, scale: float = ..., delta: float = ..., borderType: int = ...) -> UMat: ...
def SimpleBlobDetector_create(parameters: SimpleBlobDetector_Params = ...) -> SimpleBlobDetector: ...
@overload
def Sobel(src: Mat, ddepth: int, dx: int, dy: int, ksize: int = ..., scale: float = ..., delta: float = ..., borderType: int = ...) -> Mat: ...
@overload
def Sobel(src: UMat, ddepth: int, dx: int, dy: int, ksize: int = ..., scale: float = ..., delta: float = ..., borderType: int = ...) -> UMat: ...
def SparsePyrLKOpticalFlow_create(winSize: Size = ..., maxLevel: int = ..., crit: TermCriteria = ..., flags: int = ..., minEigThreshold: float = ...) -> SparsePyrLKOpticalFlow: ...
def StereoBM_create(numDisparities: int = ..., blockSize: int = ...) -> StereoBM: ...
def StereoSGBM_create(minDisparity: int = ..., numDisparities: int = ..., blockSize: int = ..., P1: int = ..., P2: int = ..., disp12MaxDiff: int = ..., preFilterCap: int = ..., uniquenessRatio: int = ..., speckleWindowSize: int = ..., speckleRange: int = ..., mode: int = ...) -> StereoSGBM: ...
def Stitcher_create(mode: Mode = ...) -> Stitcher: ...
def TrackerDaSiamRPN_create(parameters: TrackerDaSiamRPN_Params = ...) -> TrackerDaSiamRPN: ...
def TrackerGOTURN_create(parameters: TrackerGOTURN_Params = ...) -> TrackerGOTURN: ...
def TrackerMIL_create(parameters: TrackerMIL_Params = ...) -> TrackerMIL: ...
def UMat_context() -> None: ...
def UMat_queue() -> None: ...
def VariationalRefinement_create() -> VariationalRefinement: ...
def VideoWriter_fourcc(c1: str, c2: str, c3: str, c4: str) -> int: ...
@overload
def absdiff(src1: Mat, src2: Mat) -> Mat: ...
@overload
def absdiff(src1: UMat, src2: UMat) -> UMat: ...
@overload
def accumulate(src: Mat, mask: Mat = ...) -> Mat: ...
@overload
def accumulate(src: UMat, mask: UMat = ...) -> UMat: ...
@overload
def accumulateProduct(src1: Mat, src2: Mat, mask: Mat = ...) -> Mat: ...
@overload
def accumulateProduct(src1: UMat, src2: UMat, mask: UMat = ...) -> UMat: ...
@overload
def accumulateSquare(src: Mat, mask: Mat = ...) -> Mat: ...
@overload
def accumulateSquare(src: UMat, mask: UMat = ...) -> UMat: ...
@overload
def accumulateWeighted(src: Mat, alpha: float, mask: Mat = ...) -> Mat: ...
@overload
def accumulateWeighted(src: UMat, alpha: float, mask: UMat = ...) -> UMat: ...
@overload
def adaptiveThreshold(src: Mat, maxValue: float, adaptiveMethod: int, thresholdType: int, blockSize: int, C: float) -> Mat: ...
@overload
def adaptiveThreshold(src: UMat, maxValue: float, adaptiveMethod: int, thresholdType: int, blockSize: int, C: float) -> UMat: ...
@overload
def add(src1: Mat, src2: Mat, mask: Mat = ..., dtype: int = ...) -> Mat: ...
@overload
def add(src1: UMat, src2: UMat, mask: UMat = ..., dtype: int = ...) -> UMat: ...
@overload
def addText(img: Mat, text: str, org: Point, nameFont: str, pointSize: int = ..., color: Scalar = ..., weight: int = ..., style: int = ..., spacing: int = ...) -> None: ...
@overload
def addText(img: Mat, text: str, org: Point, nameFont: str, pointSize: int = ..., color: Scalar = ..., weight: int = ..., style: int = ..., spacing: int = ...) -> None: ...
@overload
def addWeighted(src1: Mat, alpha: float, src2: Mat, beta: float, gamma: float, dtype: int = ...) -> Mat: ...
@overload
def addWeighted(src1: UMat, alpha: float, src2: UMat, beta: float, gamma: float, dtype: int = ...) -> UMat: ...
@overload
def applyColorMap(src: Mat, colormap: int) -> Mat: ...
@overload
def applyColorMap(src: UMat, colormap: int) -> UMat: ...
@overload
def applyColorMap(src: Mat, userColor: Mat) -> Mat: ...
@overload
def applyColorMap(src: UMat, userColor: UMat) -> UMat: ...
@overload
def approxPolyDP(curve: Mat, epsilon: float, closed: bool) -> Mat: ...
@overload
def approxPolyDP(curve: UMat, epsilon: float, closed: bool) -> UMat: ...
@overload
def arcLength(curve: Mat, closed: bool) -> float: ...
@overload
def arcLength(curve: UMat, closed: bool) -> float: ...
@overload
def arrowedLine(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., line_type: int = ..., shift: int = ..., tipLength: float = ...) -> Mat: ...
@overload
def arrowedLine(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., line_type: int = ..., shift: int = ..., tipLength: float = ...) -> UMat: ...
@overload
def batchDistance(src1: Mat, src2: Mat, dtype: int, normType: int = ..., K: int = ..., mask: Mat = ..., update: int = ..., crosscheck: bool = ...) -> Tuple[Mat, Mat]: ...
@overload
def batchDistance(src1: UMat, src2: UMat, dtype: int, normType: int = ..., K: int = ..., mask: UMat = ..., update: int = ..., crosscheck: bool = ...) -> Tuple[UMat, UMat]: ...
@overload
def bilateralFilter(src: Mat, d: int, sigmaColor: float, sigmaSpace: float, borderType: int = ...) -> Mat: ...
@overload
def bilateralFilter(src: UMat, d: int, sigmaColor: float, sigmaSpace: float, borderType: int = ...) -> UMat: ...
@overload
def bitwise_and(src1: Mat, src2: Mat, mask: Mat = ...) -> Mat: ...
@overload
def bitwise_and(src1: UMat, src2: UMat, mask: UMat = ...) -> UMat: ...
@overload
def bitwise_not(src: Mat, mask: Mat = ...) -> Mat: ...
@overload
def bitwise_not(src: UMat, mask: UMat = ...) -> UMat: ...
@overload
def bitwise_or(src1: Mat, src2: Mat, mask: Mat = ...) -> Mat: ...
@overload
def bitwise_or(src1: UMat, src2: UMat, mask: UMat = ...) -> UMat: ...
@overload
def bitwise_xor(src1: Mat, src2: Mat, mask: Mat = ...) -> Mat: ...
@overload
def bitwise_xor(src1: UMat, src2: UMat, mask: UMat = ...) -> UMat: ...
@overload
def blendLinear(src1: Mat, src2: Mat, weights1: Mat, weights2: Mat) -> Mat: ...
@overload
def blendLinear(src1: UMat, src2: UMat, weights1: UMat, weights2: UMat) -> UMat: ...
@overload
def blur(src: Mat, ksize: Size, anchor: Point = ..., borderType: int = ...) -> Mat: ...
@overload
def blur(src: UMat, ksize: Size, anchor: Point = ..., borderType: int = ...) -> UMat: ...
def borderInterpolate(p: int, len: int, borderType: int) -> int: ...
@overload
def boundingRect(array: Mat) -> Rect: ...
@overload
def boundingRect(array: UMat) -> Rect: ...
@overload
def boxFilter(src: Mat, ddepth: int, ksize: Size, anchor: Point = ..., normalize: bool = ..., borderType: int = ...) -> Mat: ...
@overload
def boxFilter(src: UMat, ddepth: int, ksize: Size, anchor: Point = ..., normalize: bool = ..., borderType: int = ...) -> UMat: ...
@overload
def boxPoints(box: RotatedRect) -> Mat: ...
@overload
def boxPoints(box: RotatedRect) -> UMat: ...
@overload
def buildOpticalFlowPyramid(img: Mat, winSize: Size, maxLevel: int, withDerivatives: bool = ..., pyrBorder: int = ..., derivBorder: int = ..., tryReuseInputImage: bool = ...) -> Tuple[bool, Sequence[Mat]]: ...
@overload
def buildOpticalFlowPyramid(img: UMat, winSize: Size, maxLevel: int, withDerivatives: bool = ..., pyrBorder: int = ..., derivBorder: int = ..., tryReuseInputImage: bool = ...) -> Tuple[bool, Sequence[UMat]]: ...
@overload
def calcBackProject(images: Sequence[Mat], channels: Sequence[int], hist: Mat, ranges: Sequence[float], scale: float) -> Mat: ...
@overload
def calcBackProject(images: Sequence[UMat], channels: Sequence[int], hist: UMat, ranges: Sequence[float], scale: float) -> UMat: ...
@overload
def calcCovarMatrix(samples: Mat, flags: int, ctype: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def calcCovarMatrix(samples: UMat, flags: int, ctype: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def calcHist(images: Sequence[Mat], channels: Sequence[int], mask: Mat, histSize: Sequence[int], ranges: Sequence[float], accumulate: bool = ...) -> Mat: ...
@overload
def calcHist(images: Sequence[UMat], channels: Sequence[int], mask: UMat, histSize: Sequence[int], ranges: Sequence[float], accumulate: bool = ...) -> UMat: ...
@overload
def calcOpticalFlowFarneback(prev: Mat, next: Mat, pyr_scale: float, levels: int, winsize: int, iterations: int, poly_n: int, poly_sigma: float, flags: int) -> Mat: ...
@overload
def calcOpticalFlowFarneback(prev: UMat, next: UMat, pyr_scale: float, levels: int, winsize: int, iterations: int, poly_n: int, poly_sigma: float, flags: int) -> UMat: ...
@overload
def calcOpticalFlowPyrLK(prevImg: Mat, nextImg: Mat, prevPts: Mat, winSize: Size = ..., maxLevel: int = ..., criteria: TermCriteria = ..., flags: int = ..., minEigThreshold: float = ...) -> Tuple[Mat, Mat, Mat]: ...
@overload
def calcOpticalFlowPyrLK(prevImg: UMat, nextImg: UMat, prevPts: UMat, winSize: Size = ..., maxLevel: int = ..., criteria: TermCriteria = ..., flags: int = ..., minEigThreshold: float = ...) -> Tuple[UMat, UMat, UMat]: ...
@overload
def calibrateCamera(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Sequence[Mat], Sequence[Mat]]: ...
@overload
def calibrateCamera(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, Sequence[UMat], Sequence[UMat]]: ...
@overload
def calibrateCameraExtended(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Sequence[Mat], Sequence[Mat], Mat, Mat, Mat]: ...
@overload
def calibrateCameraExtended(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, Sequence[UMat], Sequence[UMat], UMat, UMat, UMat]: ...
@overload
def calibrateCameraRO(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], imageSize: Size, iFixedPoint: int, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Sequence[Mat], Sequence[Mat], Mat]: ...
@overload
def calibrateCameraRO(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], imageSize: Size, iFixedPoint: int, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, Sequence[UMat], Sequence[UMat], UMat]: ...
@overload
def calibrateCameraROExtended(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], imageSize: Size, iFixedPoint: int, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Sequence[Mat], Sequence[Mat], Mat, Mat, Mat, Mat, Mat]: ...
@overload
def calibrateCameraROExtended(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], imageSize: Size, iFixedPoint: int, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, Sequence[UMat], Sequence[UMat], UMat, UMat, UMat, UMat, UMat]: ...
@overload
def calibrationMatrixValues(cameraMatrix: Mat, imageSize: Size, apertureWidth: float, apertureHeight: float) -> Tuple[float, float, float, Point2d, float]: ...
@overload
def calibrationMatrixValues(cameraMatrix: UMat, imageSize: Size, apertureWidth: float, apertureHeight: float) -> Tuple[float, float, float, Point2d, float]: ...
@overload
def cartToPolar(x: Mat, y: Mat, angleInDegrees: bool = ...) -> Tuple[Mat, Mat]: ...
@overload
def cartToPolar(x: UMat, y: UMat, angleInDegrees: bool = ...) -> Tuple[UMat, UMat]: ...
@overload
def checkChessboard(img: Mat, size: Size) -> bool: ...
@overload
def checkChessboard(img: UMat, size: Size) -> bool: ...
def checkHardwareSupport(feature: int) -> bool: ...
@overload
def checkRange(a: Mat, quiet: bool = ..., minVal: float = ..., maxVal: float = ...) -> Tuple[float, Point]: ...
@overload
def checkRange(a: UMat, quiet: bool = ..., minVal: float = ..., maxVal: float = ...) -> Tuple[float, Point]: ...
@overload
def circle(center: Point, radius: int, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def circle(center: Point, radius: int, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
def clipLine(imgRect: Rect) -> Tuple[Point, Point, Point]: ...
@overload
def colorChange(src: Mat, mask: Mat, red_mul: float = ..., green_mul: float = ..., blue_mul: float = ...) -> Mat: ...
@overload
def colorChange(src: UMat, mask: UMat, red_mul: float = ..., green_mul: float = ..., blue_mul: float = ...) -> UMat: ...
@overload
def compare(src1: Mat, src2: Mat, cmpop: int) -> Mat: ...
@overload
def compare(src1: UMat, src2: UMat, cmpop: int) -> UMat: ...
@overload
def compareHist(H1: Mat, H2: Mat, method: int) -> float: ...
@overload
def compareHist(H1: UMat, H2: UMat, method: int) -> float: ...
@overload
def compile_args(pkg: gapi_GKernelPackage) -> GCompileArgs: ...
@overload
def compile_args(pkg: gapi_GNetPackage) -> GCompileArgs: ...
@overload
def compile_args(kernels: gapi_GKernelPackage, nets: gapi_GNetPackage) -> GCompileArgs: ...
@overload
def completeSymm(lowerToUpper: bool = ...) -> Mat: ...
@overload
def completeSymm(lowerToUpper: bool = ...) -> UMat: ...
@overload
def composeRT(rvec1: Mat, tvec1: Mat, rvec2: Mat, tvec2: Mat) -> Tuple[Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def composeRT(rvec1: UMat, tvec1: UMat, rvec2: UMat, tvec2: UMat) -> Tuple[UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def computeCorrespondEpilines(points: Mat, whichImage: int, F: Mat) -> Mat: ...
@overload
def computeCorrespondEpilines(points: UMat, whichImage: int, F: UMat) -> UMat: ...
@overload
def computeECC(templateImage: Mat, inputImage: Mat, inputMask: Mat = ...) -> float: ...
@overload
def computeECC(templateImage: UMat, inputImage: UMat, inputMask: UMat = ...) -> float: ...
@overload
def connectedComponents(image: Mat, connectivity: int = ..., ltype: int = ...) -> Tuple[int, Mat]: ...
@overload
def connectedComponents(image: UMat, connectivity: int = ..., ltype: int = ...) -> Tuple[int, UMat]: ...
@overload
def connectedComponentsWithAlgorithm(image: Mat, connectivity: int, ltype: int, ccltype: int) -> Tuple[int, Mat]: ...
@overload
def connectedComponentsWithAlgorithm(image: UMat, connectivity: int, ltype: int, ccltype: int) -> Tuple[int, UMat]: ...
@overload
def connectedComponentsWithStats(image: Mat, connectivity: int = ..., ltype: int = ...) -> Tuple[int, Mat, Mat, Mat]: ...
@overload
def connectedComponentsWithStats(image: UMat, connectivity: int = ..., ltype: int = ...) -> Tuple[int, UMat, UMat, UMat]: ...
@overload
def connectedComponentsWithStatsWithAlgorithm(image: Mat, connectivity: int, ltype: int, ccltype: int) -> Tuple[int, Mat, Mat, Mat]: ...
@overload
def connectedComponentsWithStatsWithAlgorithm(image: UMat, connectivity: int, ltype: int, ccltype: int) -> Tuple[int, UMat, UMat, UMat]: ...
@overload
def contourArea(contour: Mat, oriented: bool = ...) -> float: ...
@overload
def contourArea(contour: UMat, oriented: bool = ...) -> float: ...
@overload
def convertFp16(src: Mat) -> Mat: ...
@overload
def convertFp16(src: UMat) -> UMat: ...
@overload
def convertMaps(map1: Mat, map2: Mat, dstmap1type: int, nninterpolation: bool = ...) -> Tuple[Mat, Mat]: ...
@overload
def convertMaps(map1: UMat, map2: UMat, dstmap1type: int, nninterpolation: bool = ...) -> Tuple[UMat, UMat]: ...
@overload
def convertPointsFromHomogeneous(src: Mat, dtype: int = ...) -> Mat: ...
@overload
def convertPointsFromHomogeneous(src: UMat, dtype: int = ...) -> UMat: ...
@overload
def convertPointsToHomogeneous(src: Mat, dtype: int = ...) -> Mat: ...
@overload
def convertPointsToHomogeneous(src: UMat, dtype: int = ...) -> UMat: ...
@overload
def convertScaleAbs(src: Mat, alpha: float = ..., beta: float = ...) -> Mat: ...
@overload
def convertScaleAbs(src: UMat, alpha: float = ..., beta: float = ...) -> UMat: ...
@overload
def convexHull(points: Mat, clockwise: bool = ..., returnPoints: bool = ...) -> Mat: ...
@overload
def convexHull(points: UMat, clockwise: bool = ..., returnPoints: bool = ...) -> UMat: ...
@overload
def convexityDefects(contour: Mat, convexhull: Mat) -> Mat: ...
@overload
def convexityDefects(contour: UMat, convexhull: UMat) -> UMat: ...
@overload
def copyMakeBorder(src: Mat, top: int, bottom: int, left: int, right: int, borderType: int, value: Scalar = ...) -> Mat: ...
@overload
def copyMakeBorder(src: UMat, top: int, bottom: int, left: int, right: int, borderType: int, value: Scalar = ...) -> UMat: ...
@overload
def copyTo(src: Mat, mask: Mat) -> Mat: ...
@overload
def copyTo(src: UMat, mask: UMat) -> UMat: ...
@overload
def cornerEigenValsAndVecs(src: Mat, blockSize: int, ksize: int, borderType: int = ...) -> Mat: ...
@overload
def cornerEigenValsAndVecs(src: UMat, blockSize: int, ksize: int, borderType: int = ...) -> UMat: ...
@overload
def cornerHarris(src: Mat, blockSize: int, ksize: int, k: float, borderType: int = ...) -> Mat: ...
@overload
def cornerHarris(src: UMat, blockSize: int, ksize: int, k: float, borderType: int = ...) -> UMat: ...
@overload
def cornerMinEigenVal(src: Mat, blockSize: int, ksize: int = ..., borderType: int = ...) -> Mat: ...
@overload
def cornerMinEigenVal(src: UMat, blockSize: int, ksize: int = ..., borderType: int = ...) -> UMat: ...
@overload
def cornerSubPix(image: Mat, winSize: Size, zeroZone: Size, criteria: TermCriteria) -> Mat: ...
@overload
def cornerSubPix(image: UMat, winSize: Size, zeroZone: Size, criteria: TermCriteria) -> UMat: ...
@overload
def correctMatches(F: Mat, points1: Mat, points2: Mat) -> Tuple[Mat, Mat]: ...
@overload
def correctMatches(F: UMat, points1: UMat, points2: UMat) -> Tuple[UMat, UMat]: ...
@overload
def countNonZero(src: Mat) -> int: ...
@overload
def countNonZero(src: UMat) -> int: ...
def createAlignMTB(max_bits: int = ..., exclude_range: int = ..., cut: bool = ...) -> AlignMTB: ...
def createBackgroundSubtractorKNN(history: int = ..., dist2Threshold: float = ..., detectShadows: bool = ...) -> BackgroundSubtractorKNN: ...
def createBackgroundSubtractorMOG2(history: int = ..., varThreshold: float = ..., detectShadows: bool = ...) -> BackgroundSubtractorMOG2: ...
def createCLAHE(clipLimit: float = ..., tileGridSize: Size = ...) -> CLAHE: ...
def createCalibrateDebevec(samples: int = ..., lambda: float = ..., random: bool = ...) -> CalibrateDebevec: ...
def createCalibrateRobertson(max_iter: int = ..., threshold: float = ...) -> CalibrateRobertson: ...
def createGeneralizedHoughBallard() -> GeneralizedHoughBallard: ...
def createGeneralizedHoughGuil() -> GeneralizedHoughGuil: ...
@overload
def createHanningWindow(winSize: Size, type: int) -> Mat: ...
@overload
def createHanningWindow(winSize: Size, type: int) -> UMat: ...
def createMergeDebevec() -> MergeDebevec: ...
def createMergeMertens(contrast_weight: float = ..., saturation_weight: float = ..., exposure_weight: float = ...) -> MergeMertens: ...
def createMergeRobertson() -> MergeRobertson: ...
def createTonemap(gamma: float = ...) -> Tonemap: ...
def createTonemapDrago(gamma: float = ..., saturation: float = ..., bias: float = ...) -> TonemapDrago: ...
def createTonemapMantiuk(gamma: float = ..., scale: float = ..., saturation: float = ...) -> TonemapMantiuk: ...
def createTonemapReinhard(gamma: float = ..., intensity: float = ..., light_adapt: float = ..., color_adapt: float = ...) -> TonemapReinhard: ...
def cubeRoot(val: float) -> float: ...
@overload
def cvtColor(src: Mat, code: int, dstCn: int = ...) -> Mat: ...
@overload
def cvtColor(src: UMat, code: int, dstCn: int = ...) -> UMat: ...
@overload
def cvtColorTwoPlane(src1: Mat, src2: Mat, code: int) -> Mat: ...
@overload
def cvtColorTwoPlane(src1: UMat, src2: UMat, code: int) -> UMat: ...
@overload
def dct(src: Mat, flags: int = ...) -> Mat: ...
@overload
def dct(src: UMat, flags: int = ...) -> UMat: ...
@overload
def decolor(src: Mat) -> Tuple[Mat, Mat]: ...
@overload
def decolor(src: UMat) -> Tuple[UMat, UMat]: ...
@overload
def decomposeEssentialMat(E: Mat) -> Tuple[Mat, Mat, Mat]: ...
@overload
def decomposeEssentialMat(E: UMat) -> Tuple[UMat, UMat, UMat]: ...
@overload
def decomposeHomographyMat(H: Mat, K: Mat) -> Tuple[Sequence[Mat], Sequence[Mat], Sequence[Mat], Sequence[Mat]]: ...
@overload
def decomposeHomographyMat(H: UMat, K: UMat) -> Tuple[Sequence[UMat], Sequence[UMat], Sequence[UMat], Sequence[UMat]]: ...
@overload
def decomposeProjectionMatrix(projMatrix: Mat) -> Tuple[Mat, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def decomposeProjectionMatrix(projMatrix: UMat) -> Tuple[UMat, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def demosaicing(src: Mat, code: int, dstCn: int = ...) -> Mat: ...
@overload
def demosaicing(src: UMat, code: int, dstCn: int = ...) -> UMat: ...
@overload
def denoise_TVL1(observations: Sequence[Mat], result: Mat, lambda: float = ..., niters: int = ...) -> None: ...
@overload
def denoise_TVL1(observations: Sequence[Mat], result: Mat, lambda: float = ..., niters: int = ...) -> None: ...
def destroyAllWindows() -> None: ...
def destroyWindow(winname: str) -> None: ...
@overload
def detailEnhance(src: Mat, sigma_s: float = ..., sigma_r: float = ...) -> Mat: ...
@overload
def detailEnhance(src: UMat, sigma_s: float = ..., sigma_r: float = ...) -> UMat: ...
@overload
def determinant(mtx: Mat) -> float: ...
@overload
def determinant(mtx: UMat) -> float: ...
@overload
def dft(src: Mat, flags: int = ..., nonzeroRows: int = ...) -> Mat: ...
@overload
def dft(src: UMat, flags: int = ..., nonzeroRows: int = ...) -> UMat: ...
@overload
def dilate(src: Mat, kernel: Mat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def dilate(src: UMat, kernel: UMat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> UMat: ...
def displayOverlay(winname: str, text: str, delayms: int = ...) -> None: ...
def displayStatusBar(winname: str, text: str, delayms: int = ...) -> None: ...
@overload
def distanceTransform(src: Mat, distanceType: int, maskSize: int, dstType: int = ...) -> Mat: ...
@overload
def distanceTransform(src: UMat, distanceType: int, maskSize: int, dstType: int = ...) -> UMat: ...
@overload
def distanceTransformWithLabels(src: Mat, distanceType: int, maskSize: int, labelType: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def distanceTransformWithLabels(src: UMat, distanceType: int, maskSize: int, labelType: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def divSpectrums(a: Mat, b: Mat, flags: int, conjB: bool = ...) -> Mat: ...
@overload
def divSpectrums(a: UMat, b: UMat, flags: int, conjB: bool = ...) -> UMat: ...
@overload
def divide(src1: Mat, src2: Mat, scale: float = ..., dtype: int = ...) -> Mat: ...
@overload
def divide(src1: UMat, src2: UMat, scale: float = ..., dtype: int = ...) -> UMat: ...
@overload
def divide(scale: float, src2: Mat, dtype: int = ...) -> Mat: ...
@overload
def divide(scale: float, src2: UMat, dtype: int = ...) -> UMat: ...
@overload
def drawChessboardCorners(patternSize: Size, corners: Mat, patternWasFound: bool) -> Mat: ...
@overload
def drawChessboardCorners(patternSize: Size, corners: UMat, patternWasFound: bool) -> UMat: ...
@overload
def drawContours(contours: Sequence[Mat], contourIdx: int, color: Scalar, thickness: int = ..., lineType: int = ..., hierarchy: Mat = ..., maxLevel: int = ..., offset: Point = ...) -> Mat: ...
@overload
def drawContours(contours: Sequence[UMat], contourIdx: int, color: Scalar, thickness: int = ..., lineType: int = ..., hierarchy: UMat = ..., maxLevel: int = ..., offset: Point = ...) -> UMat: ...
@overload
def drawFrameAxes(cameraMatrix: Mat, distCoeffs: Mat, rvec: Mat, tvec: Mat, length: float, thickness: int = ...) -> Mat: ...
@overload
def drawFrameAxes(cameraMatrix: UMat, distCoeffs: UMat, rvec: UMat, tvec: UMat, length: float, thickness: int = ...) -> UMat: ...
@overload
def drawKeypoints(image: Mat, keypoints: Sequence[KeyPoint], color: Scalar = ..., flags: DrawMatchesFlags = ...) -> Mat: ...
@overload
def drawKeypoints(image: UMat, keypoints: Sequence[KeyPoint], color: Scalar = ..., flags: DrawMatchesFlags = ...) -> UMat: ...
@overload
def drawMarker(position: Point, color: Scalar, markerType: int = ..., markerSize: int = ..., thickness: int = ..., line_type: int = ...) -> Mat: ...
@overload
def drawMarker(position: Point, color: Scalar, markerType: int = ..., markerSize: int = ..., thickness: int = ..., line_type: int = ...) -> UMat: ...
@overload
def drawMatches(img1: Mat, keypoints1: Sequence[KeyPoint], img2: Mat, keypoints2: Sequence[KeyPoint], matches1to2: Sequence[DMatch], matchColor: Scalar = ..., singlePointColor: Scalar = ..., matchesMask: Sequence[str] = ..., flags: DrawMatchesFlags = ...) -> Mat: ...
@overload
def drawMatches(img1: UMat, keypoints1: Sequence[KeyPoint], img2: UMat, keypoints2: Sequence[KeyPoint], matches1to2: Sequence[DMatch], matchColor: Scalar = ..., singlePointColor: Scalar = ..., matchesMask: Sequence[str] = ..., flags: DrawMatchesFlags = ...) -> UMat: ...
@overload
def drawMatchesKnn(img1: Mat, keypoints1: Sequence[KeyPoint], img2: Mat, keypoints2: Sequence[KeyPoint], matches1to2: Sequence[Sequence[DMatch]], matchColor: Scalar = ..., singlePointColor: Scalar = ..., matchesMask: Sequence[Sequence[str]] = ..., flags: DrawMatchesFlags = ...) -> Mat: ...
@overload
def drawMatchesKnn(img1: UMat, keypoints1: Sequence[KeyPoint], img2: UMat, keypoints2: Sequence[KeyPoint], matches1to2: Sequence[Sequence[DMatch]], matchColor: Scalar = ..., singlePointColor: Scalar = ..., matchesMask: Sequence[Sequence[str]] = ..., flags: DrawMatchesFlags = ...) -> UMat: ...
@overload
def edgePreservingFilter(src: Mat, flags: int = ..., sigma_s: float = ..., sigma_r: float = ...) -> Mat: ...
@overload
def edgePreservingFilter(src: UMat, flags: int = ..., sigma_s: float = ..., sigma_r: float = ...) -> UMat: ...
@overload
def eigen(src: Mat) -> Tuple[Mat, Mat, Mat]: ...
@overload
def eigen(src: UMat) -> Tuple[UMat, UMat, UMat]: ...
@overload
def eigenNonSymmetric(src: Mat) -> Tuple[Mat, Mat]: ...
@overload
def eigenNonSymmetric(src: UMat) -> Tuple[UMat, UMat]: ...
@overload
def ellipse(center: Point, axes: Size, angle: float, startAngle: float, endAngle: float, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def ellipse(center: Point, axes: Size, angle: float, startAngle: float, endAngle: float, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def ellipse(box: RotatedRect, color: Scalar, thickness: int = ..., lineType: int = ...) -> Mat: ...
@overload
def ellipse(box: RotatedRect, color: Scalar, thickness: int = ..., lineType: int = ...) -> UMat: ...
def ellipse2Poly(center: Point, axes: Size, angle: int, arcStart: int, arcEnd: int, delta: int) -> Sequence[Point]: ...
def empty_array_desc() -> GArrayDesc: ...
def empty_gopaque_desc() -> GOpaqueDesc: ...
def empty_scalar_desc() -> GScalarDesc: ...
@overload
def equalizeHist(src: Mat) -> Mat: ...
@overload
def equalizeHist(src: UMat) -> UMat: ...
@overload
def erode(src: Mat, kernel: Mat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def erode(src: UMat, kernel: UMat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> UMat: ...
@overload
def estimateAffine2D(from: Mat, to: Mat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ..., refineIters: int = ...) -> Tuple[int, Mat]: ...
@overload
def estimateAffine2D(from: UMat, to: UMat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ..., refineIters: int = ...) -> Tuple[int, UMat]: ...
@overload
def estimateAffine2D(pts1: Mat, pts2: Mat, params: UsacParams) -> Tuple[UsacParams, Mat]: ...
@overload
def estimateAffine2D(pts1: UMat, pts2: UMat, params: UsacParams) -> Tuple[UsacParams, UMat]: ...
@overload
def estimateAffine3D(src: Mat, dst: Mat, ransacThreshold: float = ..., confidence: float = ...) -> Tuple[float, Mat, Mat]: ...
@overload
def estimateAffine3D(src: UMat, dst: UMat, ransacThreshold: float = ..., confidence: float = ...) -> Tuple[float, UMat, UMat]: ...
@overload
def estimateAffine3D(src: Mat, dst: Mat, force_rotation: bool = ...) -> Tuple[bool, float]: ...
@overload
def estimateAffine3D(src: UMat, dst: UMat, force_rotation: bool = ...) -> Tuple[bool, float]: ...
@overload
def estimateAffinePartial2D(from: Mat, to: Mat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ..., refineIters: int = ...) -> Tuple[int, Mat]: ...
@overload
def estimateAffinePartial2D(from: UMat, to: UMat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ..., refineIters: int = ...) -> Tuple[int, UMat]: ...
@overload
def estimateChessboardSharpness(image: Mat, patternSize: Size, corners: Mat, rise_distance: float = ..., vertical: bool = ...) -> Tuple[Mat, Mat]: ...
@overload
def estimateChessboardSharpness(image: UMat, patternSize: Size, corners: UMat, rise_distance: float = ..., vertical: bool = ...) -> Tuple[UMat, UMat]: ...
@overload
def estimateTranslation3D(src: Mat, dst: Mat, ransacThreshold: float = ..., confidence: float = ...) -> Tuple[float, Mat, Mat]: ...
@overload
def estimateTranslation3D(src: UMat, dst: UMat, ransacThreshold: float = ..., confidence: float = ...) -> Tuple[float, UMat, UMat]: ...
@overload
def exp(src: Mat) -> Mat: ...
@overload
def exp(src: UMat) -> UMat: ...
@overload
def extractChannel(src: Mat, coi: int) -> Mat: ...
@overload
def extractChannel(src: UMat, coi: int) -> UMat: ...
def fastAtan2(y: float, x: float) -> float: ...
@overload
def fastNlMeansDenoising(src: Mat, h: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoising(src: UMat, h: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> UMat: ...
@overload
def fastNlMeansDenoising(src: Mat, h: Sequence[float], templateWindowSize: int = ..., searchWindowSize: int = ..., normType: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoising(src: UMat, h: Sequence[float], templateWindowSize: int = ..., searchWindowSize: int = ..., normType: int = ...) -> UMat: ...
@overload
def fastNlMeansDenoisingColored(src: Mat, h: float = ..., hColor: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoisingColored(src: UMat, h: float = ..., hColor: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> UMat: ...
@overload
def fastNlMeansDenoisingColoredMulti(srcImgs: Sequence[Mat], imgToDenoiseIndex: int, temporalWindowSize: int, h: float = ..., hColor: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoisingColoredMulti(srcImgs: Sequence[UMat], imgToDenoiseIndex: int, temporalWindowSize: int, h: float = ..., hColor: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> UMat: ...
@overload
def fastNlMeansDenoisingMulti(srcImgs: Sequence[Mat], imgToDenoiseIndex: int, temporalWindowSize: int, h: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoisingMulti(srcImgs: Sequence[UMat], imgToDenoiseIndex: int, temporalWindowSize: int, h: float = ..., templateWindowSize: int = ..., searchWindowSize: int = ...) -> UMat: ...
@overload
def fastNlMeansDenoisingMulti(srcImgs: Sequence[Mat], imgToDenoiseIndex: int, temporalWindowSize: int, h: Sequence[float], templateWindowSize: int = ..., searchWindowSize: int = ..., normType: int = ...) -> Mat: ...
@overload
def fastNlMeansDenoisingMulti(srcImgs: Sequence[UMat], imgToDenoiseIndex: int, temporalWindowSize: int, h: Sequence[float], templateWindowSize: int = ..., searchWindowSize: int = ..., normType: int = ...) -> UMat: ...
@overload
def fillConvexPoly(points: Mat, color: Scalar, lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def fillConvexPoly(points: UMat, color: Scalar, lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def fillPoly(pts: Sequence[Mat], color: Scalar, lineType: int = ..., shift: int = ..., offset: Point = ...) -> Mat: ...
@overload
def fillPoly(pts: Sequence[UMat], color: Scalar, lineType: int = ..., shift: int = ..., offset: Point = ...) -> UMat: ...
@overload
def filter2D(src: Mat, ddepth: int, kernel: Mat, anchor: Point = ..., delta: float = ..., borderType: int = ...) -> Mat: ...
@overload
def filter2D(src: UMat, ddepth: int, kernel: UMat, anchor: Point = ..., delta: float = ..., borderType: int = ...) -> UMat: ...
@overload
def filter2Dp(src: Mat, kernel: Mat, params: Filter2DParams = ...) -> Mat: ...
@overload
def filter2Dp(src: UMat, kernel: UMat, params: Filter2DParams = ...) -> UMat: ...
@overload
def filterHomographyDecompByVisibleRefpoints(rotations: Sequence[Mat], normals: Sequence[Mat], beforePoints: Mat, afterPoints: Mat, pointsMask: Mat = ...) -> Mat: ...
@overload
def filterHomographyDecompByVisibleRefpoints(rotations: Sequence[UMat], normals: Sequence[UMat], beforePoints: UMat, afterPoints: UMat, pointsMask: UMat = ...) -> UMat: ...
@overload
def filterSpeckles(newVal: float, maxSpeckleSize: int, maxDiff: float) -> Tuple[Mat, Mat]: ...
@overload
def filterSpeckles(newVal: float, maxSpeckleSize: int, maxDiff: float) -> Tuple[UMat, UMat]: ...
@overload
def find4QuadCornerSubpix(img: Mat, region_size: Size) -> Tuple[Size, Mat]: ...
@overload
def find4QuadCornerSubpix(img: UMat, region_size: Size) -> Tuple[Size, UMat]: ...
@overload
def findChessboardCorners(image: Mat, patternSize: Size, flags: int = ...) -> Tuple[int, Mat]: ...
@overload
def findChessboardCorners(image: UMat, patternSize: Size, flags: int = ...) -> Tuple[int, UMat]: ...
@overload
def findChessboardCornersSB(image: Mat, patternSize: Size, flags: int = ...) -> Tuple[int, Mat]: ...
@overload
def findChessboardCornersSB(image: UMat, patternSize: Size, flags: int = ...) -> Tuple[int, UMat]: ...
@overload
def findChessboardCornersSBWithMeta(image: Mat, patternSize: Size, flags: int) -> Tuple[Mat, Mat, Mat]: ...
@overload
def findChessboardCornersSBWithMeta(image: UMat, patternSize: Size, flags: int) -> Tuple[UMat, UMat, UMat]: ...
@overload
def findCirclesGrid(image: Mat, patternSize: Size, flags: int, blobDetector: FeatureDetector, parameters: CirclesGridFinderParameters) -> Tuple[CirclesGridFinderParameters, Mat]: ...
@overload
def findCirclesGrid(image: UMat, patternSize: Size, flags: int, blobDetector: FeatureDetector, parameters: CirclesGridFinderParameters) -> Tuple[CirclesGridFinderParameters, UMat]: ...
@overload
def findCirclesGrid(image: Mat, patternSize: Size, flags: int = ..., blobDetector: FeatureDetector = ...) -> Tuple[FeatureDetector, Mat]: ...
@overload
def findCirclesGrid(image: UMat, patternSize: Size, flags: int = ..., blobDetector: FeatureDetector = ...) -> Tuple[FeatureDetector, UMat]: ...
@overload
def findContours(image: Mat, mode: int, method: int, offset: Point = ...) -> Tuple[Sequence[Mat], Mat]: ...
@overload
def findContours(image: UMat, mode: int, method: int, offset: Point = ...) -> Tuple[Sequence[UMat], UMat]: ...
@overload
def findEssentialMat(points1: Mat, points2: Mat, cameraMatrix: Mat, method: int = ..., prob: float = ..., threshold: float = ..., maxIters: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def findEssentialMat(points1: UMat, points2: UMat, cameraMatrix: UMat, method: int = ..., prob: float = ..., threshold: float = ..., maxIters: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def findEssentialMat(points1: Mat, points2: Mat, focal: float = ..., pp: Point2d = ..., method: int = ..., prob: float = ..., threshold: float = ..., maxIters: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def findEssentialMat(points1: UMat, points2: UMat, focal: float = ..., pp: Point2d = ..., method: int = ..., prob: float = ..., threshold: float = ..., maxIters: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def findEssentialMat(points1: Mat, points2: Mat, cameraMatrix1: Mat, distCoeffs1: Mat, cameraMatrix2: Mat, distCoeffs2: Mat, method: int = ..., prob: float = ..., threshold: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def findEssentialMat(points1: UMat, points2: UMat, cameraMatrix1: UMat, distCoeffs1: UMat, cameraMatrix2: UMat, distCoeffs2: UMat, method: int = ..., prob: float = ..., threshold: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def findEssentialMat(points1: Mat, points2: Mat, cameraMatrix1: Mat, cameraMatrix2: Mat, dist_coeff1: Mat, dist_coeff2: Mat, params: UsacParams) -> Tuple[UsacParams, Mat]: ...
@overload
def findEssentialMat(points1: UMat, points2: UMat, cameraMatrix1: UMat, cameraMatrix2: UMat, dist_coeff1: UMat, dist_coeff2: UMat, params: UsacParams) -> Tuple[UsacParams, UMat]: ...
@overload
def findFundamentalMat(points1: Mat, points2: Mat, method: int, ransacReprojThreshold: float, confidence: float, maxIters: int) -> Tuple[Mat, Mat]: ...
@overload
def findFundamentalMat(points1: UMat, points2: UMat, method: int, ransacReprojThreshold: float, confidence: float, maxIters: int) -> Tuple[UMat, UMat]: ...
@overload
def findFundamentalMat(points1: Mat, points2: Mat, method: int = ..., ransacReprojThreshold: float = ..., confidence: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def findFundamentalMat(points1: UMat, points2: UMat, method: int = ..., ransacReprojThreshold: float = ..., confidence: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def findFundamentalMat(points1: Mat, points2: Mat, params: UsacParams) -> Tuple[UsacParams, Mat]: ...
@overload
def findFundamentalMat(points1: UMat, points2: UMat, params: UsacParams) -> Tuple[UsacParams, UMat]: ...
@overload
def findHomography(srcPoints: Mat, dstPoints: Mat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ...) -> Tuple[float, Mat]: ...
@overload
def findHomography(srcPoints: UMat, dstPoints: UMat, method: int = ..., ransacReprojThreshold: float = ..., maxIters: int = ..., confidence: float = ...) -> Tuple[float, UMat]: ...
@overload
def findHomography(srcPoints: Mat, dstPoints: Mat, params: UsacParams) -> Tuple[UsacParams, Mat]: ...
@overload
def findHomography(srcPoints: UMat, dstPoints: UMat, params: UsacParams) -> Tuple[UsacParams, UMat]: ...
@overload
def findNonZero(src: Mat) -> Mat: ...
@overload
def findNonZero(src: UMat) -> UMat: ...
@overload
def findTransformECC(templateImage: Mat, inputImage: Mat, motionType: int, criteria: TermCriteria, inputMask: Mat, gaussFiltSize: int) -> Tuple[int, Mat]: ...
@overload
def findTransformECC(templateImage: UMat, inputImage: UMat, motionType: int, criteria: TermCriteria, inputMask: UMat, gaussFiltSize: int) -> Tuple[int, UMat]: ...
@overload
def findTransformECC(templateImage: Mat, inputImage: Mat, motionType: int = ..., criteria: TermCriteria = ..., inputMask: Mat = ...) -> Tuple[Mat, Mat]: ...
@overload
def findTransformECC(templateImage: UMat, inputImage: UMat, motionType: int = ..., criteria: TermCriteria = ..., inputMask: UMat = ...) -> Tuple[UMat, UMat]: ...
@overload
def fitEllipse(points: Mat) -> RotatedRect: ...
@overload
def fitEllipse(points: UMat) -> RotatedRect: ...
@overload
def fitEllipseAMS(points: Mat) -> RotatedRect: ...
@overload
def fitEllipseAMS(points: UMat) -> RotatedRect: ...
@overload
def fitEllipseDirect(points: Mat) -> RotatedRect: ...
@overload
def fitEllipseDirect(points: UMat) -> RotatedRect: ...
@overload
def fitLine(points: Mat, distType: int, param: float, reps: float, aeps: float) -> Mat: ...
@overload
def fitLine(points: UMat, distType: int, param: float, reps: float, aeps: float) -> UMat: ...
@overload
def flip(src: Mat, flipCode: int) -> Mat: ...
@overload
def flip(src: UMat, flipCode: int) -> UMat: ...
@overload
def floodFill(seedPoint: Point, newVal: Scalar, loDiff: Scalar = ..., upDiff: Scalar = ..., flags: int = ...) -> Tuple[int, Mat, Mat, Rect]: ...
@overload
def floodFill(seedPoint: Point, newVal: Scalar, loDiff: Scalar = ..., upDiff: Scalar = ..., flags: int = ...) -> Tuple[int, UMat, UMat, Rect]: ...
@overload
def gemm(src1: Mat, src2: Mat, alpha: float, src3: Mat, beta: float, flags: int = ...) -> Mat: ...
@overload
def gemm(src1: UMat, src2: UMat, alpha: float, src3: UMat, beta: float, flags: int = ...) -> UMat: ...
@overload
def getAffineTransform(src: Mat, dst: Mat) -> Mat: ...
@overload
def getAffineTransform(src: UMat, dst: UMat) -> Mat: ...
def getBuildInformation() -> str: ...
def getCPUFeaturesLine() -> str: ...
def getCPUTickCount() -> int: ...
@overload
def getDefaultNewCameraMatrix(cameraMatrix: Mat, imgsize: Size = ..., centerPrincipalPoint: bool = ...) -> Mat: ...
@overload
def getDefaultNewCameraMatrix(cameraMatrix: UMat, imgsize: Size = ..., centerPrincipalPoint: bool = ...) -> Mat: ...
@overload
def getDerivKernels(dx: int, dy: int, ksize: int, normalize: bool = ..., ktype: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def getDerivKernels(dx: int, dy: int, ksize: int, normalize: bool = ..., ktype: int = ...) -> Tuple[UMat, UMat]: ...
def getFontScaleFromHeight(fontFace: int, pixelHeight: int, thickness: int = ...) -> float: ...
def getGaborKernel(ksize: Size, sigma: float, theta: float, lambd: float, gamma: float, psi: float = ..., ktype: int = ...) -> Mat: ...
def getGaussianKernel(ksize: int, sigma: float, ktype: int = ...) -> Mat: ...
def getHardwareFeatureName(feature: int) -> str: ...
def getLogLevel() -> int: ...
def getNumThreads() -> int: ...
def getNumberOfCPUs() -> int: ...
def getOptimalDFTSize(vecsize: int) -> int: ...
@overload
def getOptimalNewCameraMatrix(cameraMatrix: Mat, distCoeffs: Mat, imageSize: Size, alpha: float, newImgSize: Size = ..., centerPrincipalPoint: bool = ...) -> Tuple[bool, Rect]: ...
@overload
def getOptimalNewCameraMatrix(cameraMatrix: UMat, distCoeffs: UMat, imageSize: Size, alpha: float, newImgSize: Size = ..., centerPrincipalPoint: bool = ...) -> Tuple[bool, Rect]: ...
@overload
def getPerspectiveTransform(src: Mat, dst: Mat, solveMethod: int = ...) -> Mat: ...
@overload
def getPerspectiveTransform(src: UMat, dst: UMat, solveMethod: int = ...) -> Mat: ...
@overload
def getRectSubPix(image: Mat, patchSize: Size, center: Point2f, patchType: int = ...) -> Mat: ...
@overload
def getRectSubPix(image: UMat, patchSize: Size, center: Point2f, patchType: int = ...) -> UMat: ...
def getRotationMatrix2D(center: Point2f, angle: float, scale: float) -> Mat: ...
def getStructuringElement(shape: int, ksize: Size, anchor: Point = ...) -> Mat: ...
@overload
def getTextSize(text: str, fontFace: int, fontScale: float, thickness: int) -> Tuple[int, int]: ...
@overload
def getTextSize(imgsize: Size, text: str, org: Point, fface: FontFace, size: int, weight: int = ..., flags: PutTextFlags = ..., wrap: Range = ...) -> Rect: ...
def getThreadNum() -> int: ...
def getTickCount() -> int: ...
def getTickFrequency() -> float: ...
def getTrackbarPos(trackbarname: str, winname: str) -> int: ...
def getValidDisparityROI(roi1: Rect, roi2: Rect, minDisparity: int, numberOfDisparities: int, blockSize: int) -> Rect: ...
def getVersionMajor() -> int: ...
def getVersionMinor() -> int: ...
def getVersionRevision() -> int: ...
def getVersionString() -> str: ...
def getWindowImageRect(winname: str) -> Rect: ...
def getWindowProperty(winname: str, prop_id: int) -> float: ...
@overload
def goodFeaturesToTrack(image: Mat, maxCorners: int, qualityLevel: float, minDistance: float, mask: Mat = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> Mat: ...
@overload
def goodFeaturesToTrack(image: UMat, maxCorners: int, qualityLevel: float, minDistance: float, mask: UMat = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> UMat: ...
@overload
def goodFeaturesToTrack(image: Mat, maxCorners: int, qualityLevel: float, minDistance: float, mask: Mat, blockSize: int, gradientSize: int, useHarrisDetector: bool = ..., k: float = ...) -> Mat: ...
@overload
def goodFeaturesToTrack(image: UMat, maxCorners: int, qualityLevel: float, minDistance: float, mask: UMat, blockSize: int, gradientSize: int, useHarrisDetector: bool = ..., k: float = ...) -> UMat: ...
@overload
def goodFeaturesToTrackWithQuality(image: Mat, maxCorners: int, qualityLevel: float, minDistance: float, mask: Mat, blockSize: int = ..., gradientSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def goodFeaturesToTrackWithQuality(image: UMat, maxCorners: int, qualityLevel: float, minDistance: float, mask: UMat, blockSize: int = ..., gradientSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def grabCut(img: Mat, rect: Rect, iterCount: int, mode: int = ...) -> Tuple[Mat, Mat, Mat]: ...
@overload
def grabCut(img: UMat, rect: Rect, iterCount: int, mode: int = ...) -> Tuple[UMat, UMat, UMat]: ...
def groupRectangles(groupThreshold: int, eps: float = ...) -> Tuple[Sequence[Rect], Sequence[int]]: ...
def haveImageReader(filename: str) -> bool: ...
def haveImageWriter(filename: str) -> bool: ...
def haveOpenVX() -> bool: ...
@overload
def hconcat(src: Sequence[Mat]) -> Mat: ...
@overload
def hconcat(src: Sequence[UMat]) -> UMat: ...
@overload
def idct(src: Mat, flags: int = ...) -> Mat: ...
@overload
def idct(src: UMat, flags: int = ...) -> UMat: ...
@overload
def idft(src: Mat, flags: int = ..., nonzeroRows: int = ...) -> Mat: ...
@overload
def idft(src: UMat, flags: int = ..., nonzeroRows: int = ...) -> UMat: ...
@overload
def illuminationChange(src: Mat, mask: Mat, alpha: float = ..., beta: float = ...) -> Mat: ...
@overload
def illuminationChange(src: UMat, mask: UMat, alpha: float = ..., beta: float = ...) -> UMat: ...
def imcount(filename: str, flags: int = ...) -> int: ...
@overload
def imdecode(buf: Mat, flags: int) -> Mat: ...
@overload
def imdecode(buf: UMat, flags: int) -> Mat: ...
@overload
def imencode(ext: str, img: Mat, params: Sequence[int] = ...) -> Tuple[Sequence[int], Sequence[uchar]]: ...
@overload
def imencode(ext: str, img: UMat, params: Sequence[int] = ...) -> Tuple[Sequence[int], Sequence[uchar]]: ...
def imread(filename: str, flags: int = ...) -> Mat: ...
@overload
def imreadmulti(filename: str, flags: int = ...) -> Tuple[int, Sequence[Mat]]: ...
@overload
def imreadmulti(filename: str, flags: int = ...) -> Tuple[int, Sequence[Mat]]: ...
@overload
def imreadmulti(filename: str, start: int, count: int, flags: int = ...) -> Tuple[int, Sequence[Mat]]: ...
@overload
def imreadmulti(filename: str, start: int, count: int, flags: int = ...) -> Tuple[int, Sequence[Mat]]: ...
@overload
def imshow(winname: str, mat: Mat) -> None: ...
@overload
def imshow(winname: str, mat: GpuMat) -> None: ...
@overload
def imshow(winname: str, mat: UMat) -> None: ...
@overload
def imwrite(filename: str, img: Mat, params: Sequence[int] = ...) -> bool: ...
@overload
def imwrite(filename: str, img: UMat, params: Sequence[int] = ...) -> bool: ...
@overload
def imwritemulti(filename: str, img: Sequence[Mat], params: Sequence[int] = ...) -> bool: ...
@overload
def imwritemulti(filename: str, img: Sequence[UMat], params: Sequence[int] = ...) -> bool: ...
@overload
def inRange(src: Mat, lowerb: Mat, upperb: Mat) -> Mat: ...
@overload
def inRange(src: UMat, lowerb: UMat, upperb: UMat) -> UMat: ...
@overload
def initCameraMatrix2D(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], imageSize: Size, aspectRatio: float = ...) -> Mat: ...
@overload
def initCameraMatrix2D(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], imageSize: Size, aspectRatio: float = ...) -> Mat: ...
@overload
def initInverseRectificationMap(cameraMatrix: Mat, distCoeffs: Mat, R: Mat, newCameraMatrix: Mat, size: Size, m1type: int) -> Tuple[Mat, Mat]: ...
@overload
def initInverseRectificationMap(cameraMatrix: UMat, distCoeffs: UMat, R: UMat, newCameraMatrix: UMat, size: Size, m1type: int) -> Tuple[UMat, UMat]: ...
@overload
def initUndistortRectifyMap(cameraMatrix: Mat, distCoeffs: Mat, R: Mat, newCameraMatrix: Mat, size: Size, m1type: int) -> Tuple[Mat, Mat]: ...
@overload
def initUndistortRectifyMap(cameraMatrix: UMat, distCoeffs: UMat, R: UMat, newCameraMatrix: UMat, size: Size, m1type: int) -> Tuple[UMat, UMat]: ...
@overload
def inpaint(src: Mat, inpaintMask: Mat, inpaintRadius: float, flags: int) -> Mat: ...
@overload
def inpaint(src: UMat, inpaintMask: UMat, inpaintRadius: float, flags: int) -> UMat: ...
@overload
def insertChannel(src: Mat, coi: int) -> Mat: ...
@overload
def insertChannel(src: UMat, coi: int) -> UMat: ...
@overload
def integral(src: Mat, sdepth: int = ...) -> Mat: ...
@overload
def integral(src: UMat, sdepth: int = ...) -> UMat: ...
@overload
def integral2(src: Mat, sdepth: int = ..., sqdepth: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def integral2(src: UMat, sdepth: int = ..., sqdepth: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def integral3(src: Mat, sdepth: int = ..., sqdepth: int = ...) -> Tuple[Mat, Mat, Mat]: ...
@overload
def integral3(src: UMat, sdepth: int = ..., sqdepth: int = ...) -> Tuple[UMat, UMat, UMat]: ...
@overload
def intersectConvexConvex(p1: Mat, p2: Mat, handleNested: bool = ...) -> Tuple[bool, Mat]: ...
@overload
def intersectConvexConvex(p1: UMat, p2: UMat, handleNested: bool = ...) -> Tuple[bool, UMat]: ...
@overload
def invert(src: Mat, flags: int = ...) -> Tuple[int, Mat]: ...
@overload
def invert(src: UMat, flags: int = ...) -> Tuple[int, UMat]: ...
@overload
def invertAffineTransform(M: Mat) -> Mat: ...
@overload
def invertAffineTransform(M: UMat) -> UMat: ...
@overload
def isContourConvex(contour: Mat) -> bool: ...
@overload
def isContourConvex(contour: UMat) -> bool: ...
@overload
def kmeans(data: Mat, K: int, criteria: TermCriteria, attempts: int, flags: int) -> Tuple[Mat, Mat, Mat]: ...
@overload
def kmeans(data: UMat, K: int, criteria: TermCriteria, attempts: int, flags: int) -> Tuple[UMat, UMat, UMat]: ...
@overload
def line(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def line(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def linearPolar(src: Mat, center: Point2f, maxRadius: float, flags: int) -> Mat: ...
@overload
def linearPolar(src: UMat, center: Point2f, maxRadius: float, flags: int) -> UMat: ...
@overload
def log(src: Mat) -> Mat: ...
@overload
def log(src: UMat) -> UMat: ...
@overload
def logPolar(src: Mat, center: Point2f, M: float, flags: int) -> Mat: ...
@overload
def logPolar(src: UMat, center: Point2f, M: float, flags: int) -> UMat: ...
@overload
def magnitude(x: Mat, y: Mat) -> Mat: ...
@overload
def magnitude(x: UMat, y: UMat) -> UMat: ...
@overload
def matMulDeriv(A: Mat, B: Mat) -> Tuple[Mat, Mat]: ...
@overload
def matMulDeriv(A: UMat, B: UMat) -> Tuple[UMat, UMat]: ...
@overload
def matchShapes(contour1: Mat, contour2: Mat, method: int, parameter: float) -> float: ...
@overload
def matchShapes(contour1: UMat, contour2: UMat, method: int, parameter: float) -> float: ...
@overload
def matchTemplate(image: Mat, templ: Mat, method: int, mask: Mat = ...) -> Mat: ...
@overload
def matchTemplate(image: UMat, templ: UMat, method: int, mask: UMat = ...) -> UMat: ...
@overload
def max(src1: Mat, src2: Mat) -> Mat: ...
@overload
def max(src1: UMat, src2: UMat) -> UMat: ...
@overload
def mean(src: Mat, mask: Mat = ...) -> Scalar: ...
@overload
def mean(src: UMat, mask: UMat = ...) -> Scalar: ...
@overload
def meanShift(probImage: Mat, criteria: TermCriteria) -> Tuple[TermCriteria, Rect]: ...
@overload
def meanShift(probImage: UMat, criteria: TermCriteria) -> Tuple[TermCriteria, Rect]: ...
@overload
def meanStdDev(src: Mat, mask: Mat = ...) -> Tuple[Mat, Mat]: ...
@overload
def meanStdDev(src: UMat, mask: UMat = ...) -> Tuple[UMat, UMat]: ...
@overload
def medianBlur(src: Mat, ksize: int) -> Mat: ...
@overload
def medianBlur(src: UMat, ksize: int) -> UMat: ...
@overload
def merge(mv: Sequence[Mat]) -> Mat: ...
@overload
def merge(mv: Sequence[UMat]) -> UMat: ...
@overload
def min(src1: Mat, src2: Mat) -> Mat: ...
@overload
def min(src1: UMat, src2: UMat) -> UMat: ...
@overload
def minAreaRect(points: Mat) -> RotatedRect: ...
@overload
def minAreaRect(points: UMat) -> RotatedRect: ...
@overload
def minEnclosingCircle(points: Mat) -> Tuple[Point2f, float]: ...
@overload
def minEnclosingCircle(points: UMat) -> Tuple[Point2f, float]: ...
@overload
def minEnclosingTriangle(points: Mat) -> Tuple[Mat, Mat]: ...
@overload
def minEnclosingTriangle(points: UMat) -> Tuple[UMat, UMat]: ...
@overload
def minMaxLoc(src: Mat, mask: Mat = ...) -> Tuple[float, float, Point, Point]: ...
@overload
def minMaxLoc(src: UMat, mask: UMat = ...) -> Tuple[float, float, Point, Point]: ...
@overload
def mixChannels(src: Sequence[Mat], fromTo: Sequence[int]) -> Sequence[Mat]: ...
@overload
def mixChannels(src: Sequence[UMat], fromTo: Sequence[int]) -> Sequence[UMat]: ...
@overload
def moments(array: Mat, binaryImage: bool = ...) -> Moments: ...
@overload
def moments(array: UMat, binaryImage: bool = ...) -> Moments: ...
@overload
def morphologyEx(src: Mat, op: int, kernel: Mat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def morphologyEx(src: UMat, op: int, kernel: UMat, anchor: Point = ..., iterations: int = ..., borderType: int = ..., borderValue: Scalar = ...) -> UMat: ...
def moveWindow(winname: str, x: int, y: int) -> None: ...
@overload
def mulSpectrums(a: Mat, b: Mat, flags: int, conjB: bool = ...) -> Mat: ...
@overload
def mulSpectrums(a: UMat, b: UMat, flags: int, conjB: bool = ...) -> UMat: ...
@overload
def mulTransposed(src: Mat, aTa: bool, delta: Mat = ..., scale: float = ..., dtype: int = ...) -> Mat: ...
@overload
def mulTransposed(src: UMat, aTa: bool, delta: UMat = ..., scale: float = ..., dtype: int = ...) -> UMat: ...
@overload
def multiply(src1: Mat, src2: Mat, scale: float = ..., dtype: int = ...) -> Mat: ...
@overload
def multiply(src1: UMat, src2: UMat, scale: float = ..., dtype: int = ...) -> UMat: ...
def namedWindow(winname: str, flags: int = ...) -> None: ...
@overload
def norm(src1: Mat, normType: int = ..., mask: Mat = ...) -> float: ...
@overload
def norm(src1: UMat, normType: int = ..., mask: UMat = ...) -> float: ...
@overload
def norm(src1: Mat, src2: Mat, normType: int = ..., mask: Mat = ...) -> float: ...
@overload
def norm(src1: UMat, src2: UMat, normType: int = ..., mask: UMat = ...) -> float: ...
@overload
def normalize(src: Mat, alpha: float = ..., beta: float = ..., norm_type: int = ..., dtype: int = ..., mask: Mat = ...) -> Mat: ...
@overload
def normalize(src: UMat, alpha: float = ..., beta: float = ..., norm_type: int = ..., dtype: int = ..., mask: UMat = ...) -> UMat: ...
@overload
def patchNaNs(val: float = ...) -> Mat: ...
@overload
def patchNaNs(val: float = ...) -> UMat: ...
@overload
def pencilSketch(src: Mat, sigma_s: float = ..., sigma_r: float = ..., shade_factor: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def pencilSketch(src: UMat, sigma_s: float = ..., sigma_r: float = ..., shade_factor: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def perspectiveTransform(src: Mat, m: Mat) -> Mat: ...
@overload
def perspectiveTransform(src: UMat, m: UMat) -> UMat: ...
@overload
def phase(x: Mat, y: Mat, angleInDegrees: bool = ...) -> Mat: ...
@overload
def phase(x: UMat, y: UMat, angleInDegrees: bool = ...) -> UMat: ...
@overload
def phaseCorrelate(src1: Mat, src2: Mat, window: Mat = ...) -> Tuple[float, float]: ...
@overload
def phaseCorrelate(src1: UMat, src2: UMat, window: UMat = ...) -> Tuple[float, float]: ...
@overload
def pointPolygonTest(contour: Mat, pt: Point2f, measureDist: bool) -> float: ...
@overload
def pointPolygonTest(contour: UMat, pt: Point2f, measureDist: bool) -> float: ...
@overload
def polarToCart(magnitude: Mat, angle: Mat, angleInDegrees: bool = ...) -> Tuple[Mat, Mat]: ...
@overload
def polarToCart(magnitude: UMat, angle: UMat, angleInDegrees: bool = ...) -> Tuple[UMat, UMat]: ...
def pollKey() -> int: ...
@overload
def polylines(pts: Sequence[Mat], isClosed: bool, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def polylines(pts: Sequence[UMat], isClosed: bool, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def pow(src: Mat, power: float) -> Mat: ...
@overload
def pow(src: UMat, power: float) -> UMat: ...
@overload
def preCornerDetect(src: Mat, ksize: int, borderType: int = ...) -> Mat: ...
@overload
def preCornerDetect(src: UMat, ksize: int, borderType: int = ...) -> UMat: ...
@overload
def projectPoints(objectPoints: Mat, rvec: Mat, tvec: Mat, cameraMatrix: Mat, distCoeffs: Mat, aspectRatio: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def projectPoints(objectPoints: UMat, rvec: UMat, tvec: UMat, cameraMatrix: UMat, distCoeffs: UMat, aspectRatio: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def projectPointsSepJ(objectPoints: Mat, rvec: Mat, tvec: Mat, cameraMatrix: Mat, distCoeffs: Mat, aspectRatio: float = ...) -> Tuple[Mat, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def projectPointsSepJ(objectPoints: UMat, rvec: UMat, tvec: UMat, cameraMatrix: UMat, distCoeffs: UMat, aspectRatio: float = ...) -> Tuple[UMat, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def putText(text: str, org: Point, fontFace: int, fontScale: float, color: Scalar, thickness: int = ..., lineType: int = ..., bottomLeftOrigin: bool = ...) -> Mat: ...
@overload
def putText(text: str, org: Point, fontFace: int, fontScale: float, color: Scalar, thickness: int = ..., lineType: int = ..., bottomLeftOrigin: bool = ...) -> UMat: ...
@overload
def putText(text: str, org: Point, color: Scalar, fface: FontFace, size: int, weight: int = ..., flags: PutTextFlags = ..., wrap: Range = ...) -> Tuple[Range, Mat]: ...
@overload
def putText(text: str, org: Point, color: Scalar, fface: FontFace, size: int, weight: int = ..., flags: PutTextFlags = ..., wrap: Range = ...) -> Tuple[Range, UMat]: ...
@overload
def pyrDown(src: Mat, dstsize: Size = ..., borderType: int = ...) -> Mat: ...
@overload
def pyrDown(src: UMat, dstsize: Size = ..., borderType: int = ...) -> UMat: ...
@overload
def pyrMeanShiftFiltering(src: Mat, sp: float, sr: float, maxLevel: int = ..., termcrit: TermCriteria = ...) -> Mat: ...
@overload
def pyrMeanShiftFiltering(src: UMat, sp: float, sr: float, maxLevel: int = ..., termcrit: TermCriteria = ...) -> UMat: ...
@overload
def pyrUp(src: Mat, dstsize: Size = ..., borderType: int = ...) -> Mat: ...
@overload
def pyrUp(src: UMat, dstsize: Size = ..., borderType: int = ...) -> UMat: ...
@overload
def randShuffle(iterFactor: float = ..., rng: RNG = ...) -> Mat: ...
@overload
def randShuffle(iterFactor: float = ..., rng: RNG = ...) -> UMat: ...
@overload
def randn(mean: Mat, stddev: Mat) -> Mat: ...
@overload
def randn(mean: UMat, stddev: UMat) -> UMat: ...
@overload
def randu(low: Mat, high: Mat) -> Mat: ...
@overload
def randu(low: UMat, high: UMat) -> UMat: ...
def readOpticalFlow(path: str) -> Mat: ...
@overload
def recoverPose(E: Mat, points1: Mat, points2: Mat, cameraMatrix: Mat) -> Tuple[Mat, Mat, Mat, Mat]: ...
@overload
def recoverPose(E: UMat, points1: UMat, points2: UMat, cameraMatrix: UMat) -> Tuple[UMat, UMat, UMat, UMat]: ...
@overload
def recoverPose(E: Mat, points1: Mat, points2: Mat, focal: float = ..., pp: Point2d = ...) -> Tuple[Mat, Mat, Mat, Mat]: ...
@overload
def recoverPose(E: UMat, points1: UMat, points2: UMat, focal: float = ..., pp: Point2d = ...) -> Tuple[UMat, UMat, UMat, UMat]: ...
@overload
def recoverPose(E: Mat, points1: Mat, points2: Mat, cameraMatrix: Mat, distanceThresh: float) -> Tuple[Mat, Mat, Mat, Mat, Mat]: ...
@overload
def recoverPose(E: UMat, points1: UMat, points2: UMat, cameraMatrix: UMat, distanceThresh: float) -> Tuple[UMat, UMat, UMat, UMat, UMat]: ...
@overload
def rectangle(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def rectangle(pt1: Point, pt2: Point, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def rectangle(rec: Rect, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> Mat: ...
@overload
def rectangle(rec: Rect, color: Scalar, thickness: int = ..., lineType: int = ..., shift: int = ...) -> UMat: ...
@overload
def reduce(src: Mat, dim: int, rtype: int, dtype: int = ...) -> Mat: ...
@overload
def reduce(src: UMat, dim: int, rtype: int, dtype: int = ...) -> UMat: ...
@overload
def remap(src: Mat, map1: Mat, map2: Mat, interpolation: int, borderMode: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def remap(src: UMat, map1: UMat, map2: UMat, interpolation: int, borderMode: int = ..., borderValue: Scalar = ...) -> UMat: ...
@overload
def repeat(src: Mat, ny: int, nx: int) -> Mat: ...
@overload
def repeat(src: UMat, ny: int, nx: int) -> UMat: ...
@overload
def reprojectImageTo3D(disparity: Mat, Q: Mat, handleMissingValues: bool = ..., ddepth: int = ...) -> Mat: ...
@overload
def reprojectImageTo3D(disparity: UMat, Q: UMat, handleMissingValues: bool = ..., ddepth: int = ...) -> UMat: ...
@overload
def resize(src: Mat, dsize: Size, fx: float = ..., fy: float = ..., interpolation: int = ...) -> Mat: ...
@overload
def resize(src: UMat, dsize: Size, fx: float = ..., fy: float = ..., interpolation: int = ...) -> UMat: ...
@overload
def resizeWindow(winname: str, width: int, height: int) -> None: ...
@overload
def resizeWindow(winname: str, size: Size) -> None: ...
@overload
def rotate(src: Mat, rotateCode: int) -> Mat: ...
@overload
def rotate(src: UMat, rotateCode: int) -> UMat: ...
@overload
def rotatedRectangleIntersection(rect1: RotatedRect, rect2: RotatedRect) -> Tuple[Mat, Mat]: ...
@overload
def rotatedRectangleIntersection(rect1: RotatedRect, rect2: RotatedRect) -> Tuple[UMat, UMat]: ...
@overload
def sampsonDistance(pt1: Mat, pt2: Mat, F: Mat) -> float: ...
@overload
def sampsonDistance(pt1: UMat, pt2: UMat, F: UMat) -> float: ...
@overload
def scaleAdd(src1: Mat, alpha: float, src2: Mat) -> Mat: ...
@overload
def scaleAdd(src1: UMat, alpha: float, src2: UMat) -> UMat: ...
@overload
def seamlessClone(src: Mat, dst: Mat, mask: Mat, p: Point, flags: int) -> Mat: ...
@overload
def seamlessClone(src: UMat, dst: UMat, mask: UMat, p: Point, flags: int) -> UMat: ...
@overload
def selectROI(windowName: str, img: Mat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Rect: ...
@overload
def selectROI(windowName: str, img: UMat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Rect: ...
@overload
def selectROI(img: Mat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Rect: ...
@overload
def selectROI(img: UMat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Rect: ...
@overload
def selectROIs(windowName: str, img: Mat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Sequence[Rect]: ...
@overload
def selectROIs(windowName: str, img: UMat, showCrosshair: bool = ..., fromCenter: bool = ...) -> Sequence[Rect]: ...
@overload
def sepFilter2D(src: Mat, ddepth: int, kernelX: Mat, kernelY: Mat, anchor: Point = ..., delta: float = ..., borderType: int = ...) -> Mat: ...
@overload
def sepFilter2D(src: UMat, ddepth: int, kernelX: UMat, kernelY: UMat, anchor: Point = ..., delta: float = ..., borderType: int = ...) -> UMat: ...
@overload
def setIdentity(s: Scalar = ...) -> Mat: ...
@overload
def setIdentity(s: Scalar = ...) -> UMat: ...
def setLogLevel(level: int) -> int: ...
def setNumThreads(nthreads: int) -> None: ...
def setRNGSeed(seed: int) -> None: ...
def setTrackbarMax(trackbarname: str, winname: str, maxval: int) -> None: ...
def setTrackbarMin(trackbarname: str, winname: str, minval: int) -> None: ...
def setTrackbarPos(trackbarname: str, winname: str, pos: int) -> None: ...
def setUseOpenVX(flag: bool) -> None: ...
def setUseOptimized(onoff: bool) -> None: ...
def setWindowProperty(winname: str, prop_id: int, prop_value: float) -> None: ...
def setWindowTitle(winname: str, title: str) -> None: ...
@overload
def solve(src1: Mat, src2: Mat, flags: int = ...) -> Tuple[int, Mat]: ...
@overload
def solve(src1: UMat, src2: UMat, flags: int = ...) -> Tuple[int, UMat]: ...
@overload
def solveCubic(coeffs: Mat) -> Tuple[Mat, Mat]: ...
@overload
def solveCubic(coeffs: UMat) -> Tuple[UMat, UMat]: ...
@overload
def solveLP(Func: Mat, Constr: Mat) -> Tuple[Mat, Mat]: ...
@overload
def solveLP(Func: UMat, Constr: UMat) -> Tuple[UMat, UMat]: ...
@overload
def solveP3P(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, flags: int) -> Tuple[int, Sequence[Mat], Sequence[Mat]]: ...
@overload
def solveP3P(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, flags: int) -> Tuple[int, Sequence[UMat], Sequence[UMat]]: ...
@overload
def solvePnP(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, useExtrinsicGuess: bool = ..., flags: int = ...) -> Tuple[int, Mat, Mat]: ...
@overload
def solvePnP(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, useExtrinsicGuess: bool = ..., flags: int = ...) -> Tuple[int, UMat, UMat]: ...
@overload
def solvePnPGeneric(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, useExtrinsicGuess: bool = ..., flags: int = ..., rvec: Mat = ..., tvec: Mat = ...) -> Tuple[Mat, Sequence[Mat], Sequence[Mat], Mat]: ...
@overload
def solvePnPGeneric(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, useExtrinsicGuess: bool = ..., flags: int = ..., rvec: UMat = ..., tvec: UMat = ...) -> Tuple[UMat, Sequence[UMat], Sequence[UMat], UMat]: ...
@overload
def solvePnPRansac(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, useExtrinsicGuess: bool = ..., iterationsCount: int = ..., reprojectionError: float = ..., confidence: float = ..., flags: int = ...) -> Tuple[int, Mat, Mat, Mat]: ...
@overload
def solvePnPRansac(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, useExtrinsicGuess: bool = ..., iterationsCount: int = ..., reprojectionError: float = ..., confidence: float = ..., flags: int = ...) -> Tuple[int, UMat, UMat, UMat]: ...
@overload
def solvePnPRansac(objectPoints: Mat, imagePoints: Mat, distCoeffs: Mat, params: UsacParams = ...) -> Tuple[UsacParams, Mat, Mat, Mat, Mat]: ...
@overload
def solvePnPRansac(objectPoints: UMat, imagePoints: UMat, distCoeffs: UMat, params: UsacParams = ...) -> Tuple[UsacParams, UMat, UMat, UMat, UMat]: ...
@overload
def solvePnPRefineLM(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, criteria: TermCriteria = ...) -> Tuple[Mat, Mat]: ...
@overload
def solvePnPRefineLM(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, criteria: TermCriteria = ...) -> Tuple[UMat, UMat]: ...
@overload
def solvePnPRefineVVS(objectPoints: Mat, imagePoints: Mat, cameraMatrix: Mat, distCoeffs: Mat, criteria: TermCriteria = ..., VVSlambda: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def solvePnPRefineVVS(objectPoints: UMat, imagePoints: UMat, cameraMatrix: UMat, distCoeffs: UMat, criteria: TermCriteria = ..., VVSlambda: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def solvePoly(coeffs: Mat, maxIters: int = ...) -> Tuple[int, Mat]: ...
@overload
def solvePoly(coeffs: UMat, maxIters: int = ...) -> Tuple[int, UMat]: ...
@overload
def sort(src: Mat, flags: int) -> Mat: ...
@overload
def sort(src: UMat, flags: int) -> UMat: ...
@overload
def sortIdx(src: Mat, flags: int) -> Mat: ...
@overload
def sortIdx(src: UMat, flags: int) -> UMat: ...
@overload
def spatialGradient(src: Mat, ksize: int = ..., borderType: int = ...) -> Tuple[Mat, Mat]: ...
@overload
def spatialGradient(src: UMat, ksize: int = ..., borderType: int = ...) -> Tuple[UMat, UMat]: ...
@overload
def split(m: Mat) -> Sequence[Mat]: ...
@overload
def split(m: UMat) -> Sequence[UMat]: ...
@overload
def sqrBoxFilter(src: Mat, ddepth: int, ksize: Size, anchor: Point = ..., normalize: bool = ..., borderType: int = ...) -> Mat: ...
@overload
def sqrBoxFilter(src: UMat, ddepth: int, ksize: Size, anchor: Point = ..., normalize: bool = ..., borderType: int = ...) -> UMat: ...
@overload
def sqrt(src: Mat) -> Mat: ...
@overload
def sqrt(src: UMat) -> UMat: ...
def startWindowThread() -> int: ...
@overload
def stereoCalibrate(objectPoints: Sequence[Mat], imagePoints1: Sequence[Mat], imagePoints2: Sequence[Mat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def stereoCalibrate(objectPoints: Sequence[UMat], imagePoints1: Sequence[UMat], imagePoints2: Sequence[UMat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def stereoCalibrateExtended(objectPoints: Sequence[Mat], imagePoints1: Sequence[Mat], imagePoints2: Sequence[Mat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def stereoCalibrateExtended(objectPoints: Sequence[UMat], imagePoints1: Sequence[UMat], imagePoints2: Sequence[UMat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def stereoRectify(cameraMatrix1: Mat, distCoeffs1: Mat, cameraMatrix2: Mat, distCoeffs2: Mat, imageSize: Size, R: Mat, T: Mat, flags: int = ..., alpha: float = ..., newImageSize: Size = ...) -> Tuple[Mat, Mat, Mat, Mat, Mat, Rect, Rect]: ...
@overload
def stereoRectify(cameraMatrix1: UMat, distCoeffs1: UMat, cameraMatrix2: UMat, distCoeffs2: UMat, imageSize: Size, R: UMat, T: UMat, flags: int = ..., alpha: float = ..., newImageSize: Size = ...) -> Tuple[UMat, UMat, UMat, UMat, UMat, Rect, Rect]: ...
@overload
def stereoRectifyUncalibrated(points1: Mat, points2: Mat, F: Mat, imgSize: Size, threshold: float = ...) -> Tuple[float, Mat, Mat]: ...
@overload
def stereoRectifyUncalibrated(points1: UMat, points2: UMat, F: UMat, imgSize: Size, threshold: float = ...) -> Tuple[float, UMat, UMat]: ...
@overload
def stylization(src: Mat, sigma_s: float = ..., sigma_r: float = ...) -> Mat: ...
@overload
def stylization(src: UMat, sigma_s: float = ..., sigma_r: float = ...) -> UMat: ...
@overload
def subtract(src1: Mat, src2: Mat, mask: Mat = ..., dtype: int = ...) -> Mat: ...
@overload
def subtract(src1: UMat, src2: UMat, mask: UMat = ..., dtype: int = ...) -> UMat: ...
@overload
def sumElems(src: Mat) -> Scalar: ...
@overload
def sumElems(src: UMat) -> Scalar: ...
@overload
def textureFlattening(src: Mat, mask: Mat, low_threshold: float = ..., high_threshold: float = ..., kernel_size: int = ...) -> Mat: ...
@overload
def textureFlattening(src: UMat, mask: UMat, low_threshold: float = ..., high_threshold: float = ..., kernel_size: int = ...) -> UMat: ...
@overload
def threshold(src: Mat, thresh: float, maxval: float, type: int) -> Tuple[int, Mat]: ...
@overload
def threshold(src: UMat, thresh: float, maxval: float, type: int) -> Tuple[int, UMat]: ...
@overload
def trace(mtx: Mat) -> Scalar: ...
@overload
def trace(mtx: UMat) -> Scalar: ...
@overload
def transform(src: Mat, m: Mat) -> Mat: ...
@overload
def transform(src: UMat, m: UMat) -> UMat: ...
@overload
def transpose(src: Mat) -> Mat: ...
@overload
def transpose(src: UMat) -> UMat: ...
@overload
def triangulatePoints(projMatr1: Mat, projMatr2: Mat, projPoints1: Mat, projPoints2: Mat) -> Mat: ...
@overload
def triangulatePoints(projMatr1: UMat, projMatr2: UMat, projPoints1: UMat, projPoints2: UMat) -> UMat: ...
@overload
def undistort(src: Mat, cameraMatrix: Mat, distCoeffs: Mat, newCameraMatrix: Mat = ...) -> Mat: ...
@overload
def undistort(src: UMat, cameraMatrix: UMat, distCoeffs: UMat, newCameraMatrix: UMat = ...) -> UMat: ...
@overload
def undistortPoints(src: Mat, cameraMatrix: Mat, distCoeffs: Mat, R: Mat = ..., P: Mat = ..., criteria: TermCriteria = ...) -> Mat: ...
@overload
def undistortPoints(src: UMat, cameraMatrix: UMat, distCoeffs: UMat, R: UMat = ..., P: UMat = ..., criteria: TermCriteria = ...) -> UMat: ...
def useOpenVX() -> bool: ...
def useOptimized() -> bool: ...
@overload
def validateDisparity(cost: Mat, minDisparity: int, numberOfDisparities: int, disp12MaxDisp: int = ...) -> Mat: ...
@overload
def validateDisparity(cost: UMat, minDisparity: int, numberOfDisparities: int, disp12MaxDisp: int = ...) -> UMat: ...
@overload
def vconcat(src: Sequence[Mat]) -> Mat: ...
@overload
def vconcat(src: Sequence[UMat]) -> UMat: ...
def waitKey(delay: int = ...) -> int: ...
def waitKeyEx(delay: int = ...) -> int: ...
@overload
def warpAffine(src: Mat, M: Mat, dsize: Size, flags: int = ..., borderMode: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def warpAffine(src: UMat, M: UMat, dsize: Size, flags: int = ..., borderMode: int = ..., borderValue: Scalar = ...) -> UMat: ...
@overload
def warpPerspective(src: Mat, M: Mat, dsize: Size, flags: int = ..., borderMode: int = ..., borderValue: Scalar = ...) -> Mat: ...
@overload
def warpPerspective(src: UMat, M: UMat, dsize: Size, flags: int = ..., borderMode: int = ..., borderValue: Scalar = ...) -> UMat: ...
@overload
def warpPolar(src: Mat, dsize: Size, center: Point2f, maxRadius: float, flags: int) -> Mat: ...
@overload
def warpPolar(src: UMat, dsize: Size, center: Point2f, maxRadius: float, flags: int) -> UMat: ...
@overload
def watershed(image: Mat) -> Mat: ...
@overload
def watershed(image: UMat) -> UMat: ...
@overload
def writeOpticalFlow(path: str, flow: Mat) -> bool: ...
@overload
def writeOpticalFlow(path: str, flow: UMat) -> bool: ...
def Event_elapsedTime(start: Event, end: Event) -> float: ...
def GpuMat_defaultAllocator() -> GpuMat_Allocator: ...
def GpuMat_setDefaultAllocator(allocator: GpuMat_Allocator) -> None: ...
def Stream_Null() -> Stream: ...
def TargetArchs_has(major: int, minor: int) -> bool: ...
def TargetArchs_hasBin(major: int, minor: int) -> bool: ...
def TargetArchs_hasEqualOrGreater(major: int, minor: int) -> bool: ...
def TargetArchs_hasEqualOrGreaterBin(major: int, minor: int) -> bool: ...
def TargetArchs_hasEqualOrGreaterPtx(major: int, minor: int) -> bool: ...
def TargetArchs_hasEqualOrLessPtx(major: int, minor: int) -> bool: ...
def TargetArchs_hasPtx(major: int, minor: int) -> bool: ...
@overload
def createContinuous(rows: int, cols: int, type: int) -> Mat: ...
@overload
def createContinuous(rows: int, cols: int, type: int) -> GpuMat: ...
@overload
def createContinuous(rows: int, cols: int, type: int) -> UMat: ...
@overload
def ensureSizeIsEnough(rows: int, cols: int, type: int) -> Mat: ...
@overload
def ensureSizeIsEnough(rows: int, cols: int, type: int) -> GpuMat: ...
@overload
def ensureSizeIsEnough(rows: int, cols: int, type: int) -> UMat: ...
def getCudaEnabledDeviceCount() -> int: ...
def getDevice() -> int: ...
def printCudaDeviceInfo(device: int) -> None: ...
def printShortCudaDeviceInfo(device: int) -> None: ...
@overload
def registerPageLocked(m: Mat) -> None: ...
@overload
def registerPageLocked(m: Mat) -> None: ...
@overload
def registerPageLocked(m: Mat) -> None: ...
def resetDevice() -> None: ...
def setBufferPoolConfig(deviceId: int, stackSize: int, stackCount: int) -> None: ...
def setBufferPoolUsage(on: bool) -> None: ...
def setDevice(device: int) -> None: ...
@overload
def unregisterPageLocked(m: Mat) -> None: ...
@overload
def unregisterPageLocked(m: Mat) -> None: ...
@overload
def unregisterPageLocked(m: Mat) -> None: ...
def BestOf2NearestMatcher_create(try_use_gpu: bool = ..., match_conf: float = ..., num_matches_thresh1: int = ..., num_matches_thresh2: int = ...) -> BestOf2NearestMatcher: ...
def Blender_createDefault(type: int, try_gpu: bool = ...) -> Blender: ...
def ExposureCompensator_createDefault(type: int) -> ExposureCompensator: ...
def SeamFinder_createDefault(type: int) -> SeamFinder: ...
def Timelapser_createDefault(type: int) -> Timelapser: ...
@overload
def calibrateRotatingCamera(Hs: Sequence[Mat]) -> Tuple[Mat, Mat]: ...
@overload
def calibrateRotatingCamera(Hs: Sequence[Mat]) -> Tuple[Mat, Mat]: ...
@overload
def computeImageFeatures(featuresFinder: Feature2D, images: Sequence[Mat], masks: Sequence[Mat] = ...) -> Sequence[ImageFeatures]: ...
@overload
def computeImageFeatures(featuresFinder: Feature2D, images: Sequence[UMat], masks: Sequence[UMat] = ...) -> Sequence[ImageFeatures]: ...
@overload
def computeImageFeatures2(featuresFinder: Feature2D, image: Mat, mask: Mat = ...) -> ImageFeatures: ...
@overload
def computeImageFeatures2(featuresFinder: Feature2D, image: UMat, mask: UMat = ...) -> ImageFeatures: ...
@overload
def createLaplacePyr(img: Mat, num_levels: int) -> Sequence[UMat]: ...
@overload
def createLaplacePyr(img: UMat, num_levels: int) -> Sequence[UMat]: ...
@overload
def createLaplacePyrGpu(img: Mat, num_levels: int) -> Sequence[UMat]: ...
@overload
def createLaplacePyrGpu(img: UMat, num_levels: int) -> Sequence[UMat]: ...
@overload
def createWeightMap(mask: Mat, sharpness: float) -> Mat: ...
@overload
def createWeightMap(mask: UMat, sharpness: float) -> UMat: ...
@overload
def focalsFromHomography(H: Mat, f0: float, f1: float, f0_ok: bool, f1_ok: bool) -> None: ...
@overload
def focalsFromHomography(H: Mat, f0: float, f1: float, f0_ok: bool, f1_ok: bool) -> None: ...
def leaveBiggestComponent(features: Sequence[ImageFeatures], pairwise_matches: Sequence[MatchesInfo], conf_threshold: float) -> Sequence[int]: ...
def matchesGraphAsString(pathes: Sequence[str], pairwise_matches: Sequence[MatchesInfo], conf_threshold: float) -> str: ...
@overload
def normalizeUsingWeightMap(weight: Mat) -> Mat: ...
@overload
def normalizeUsingWeightMap(weight: UMat) -> UMat: ...
def overlapRoi(tl1: Point, tl2: Point, sz1: Size, sz2: Size, roi: Rect) -> bool: ...
def restoreImageFromLaplacePyr() -> Sequence[UMat]: ...
def restoreImageFromLaplacePyrGpu() -> Sequence[UMat]: ...
@overload
def resultRoi(corners: Sequence[Point], images: Sequence[UMat]) -> Rect: ...
@overload
def resultRoi(corners: Sequence[Point], sizes: Sequence[Size]) -> Rect: ...
def resultRoiIntersection(corners: Sequence[Point], sizes: Sequence[Size]) -> Rect: ...
def resultTl(corners: Sequence[Point]) -> Point: ...
def selectRandomSubset(count: int, size: int, subset: Sequence[int]) -> None: ...
def stitchingLogLevel() -> int: ...
@overload
def waveCorrect(kind: WaveCorrectKind) -> Sequence[Mat]: ...
@overload
def waveCorrect(kind: WaveCorrectKind) -> Sequence[Mat]: ...
def NMSBoxes(bboxes: Sequence[Rect2d], scores: Sequence[float], score_threshold: float, nms_threshold: float, eta: float = ..., top_k: int = ...) -> Sequence[int]: ...
def NMSBoxesRotated(bboxes: Sequence[RotatedRect], scores: Sequence[float], score_threshold: float, nms_threshold: float, eta: float = ..., top_k: int = ...) -> Sequence[int]: ...
@overload
def Net_readFromModelOptimizer(xml: str, bin: str) -> Net: ...
@overload
def Net_readFromModelOptimizer(bufferModelConfig: Sequence[uchar], bufferWeights: Sequence[uchar]) -> Net: ...
@overload
def blobFromImage(image: Mat, scalefactor: float = ..., size: Size = ..., mean: Scalar = ..., swapRB: bool = ..., crop: bool = ..., ddepth: int = ...) -> Mat: ...
@overload
def blobFromImage(image: UMat, scalefactor: float = ..., size: Size = ..., mean: Scalar = ..., swapRB: bool = ..., crop: bool = ..., ddepth: int = ...) -> Mat: ...
@overload
def blobFromImages(images: Sequence[Mat], scalefactor: float = ..., size: Size = ..., mean: Scalar = ..., swapRB: bool = ..., crop: bool = ..., ddepth: int = ...) -> Mat: ...
@overload
def blobFromImages(images: Sequence[UMat], scalefactor: float = ..., size: Size = ..., mean: Scalar = ..., swapRB: bool = ..., crop: bool = ..., ddepth: int = ...) -> Mat: ...
def getAvailableTargets(be: dnn_Backend) -> Sequence[Target]: ...
@overload
def imagesFromBlob(blob_: Mat) -> Sequence[Mat]: ...
@overload
def imagesFromBlob(blob_: Mat) -> Sequence[UMat]: ...
@overload
def readNet(model: str, config: str = ..., framework: str = ...) -> Net: ...
@overload
def readNet(framework: str, bufferModel: Sequence[uchar], bufferConfig: Sequence[uchar] = ...) -> Net: ...
@overload
def readNetFromCaffe(prototxt: str, caffeModel: str = ...) -> Net: ...
@overload
def readNetFromCaffe(bufferProto: Sequence[uchar], bufferModel: Sequence[uchar] = ...) -> Net: ...
@overload
def readNetFromDarknet(cfgFile: str, darknetModel: str = ...) -> Net: ...
@overload
def readNetFromDarknet(bufferCfg: Sequence[uchar], bufferModel: Sequence[uchar] = ...) -> Net: ...
@overload
def readNetFromModelOptimizer(xml: str, bin: str) -> Net: ...
@overload
def readNetFromModelOptimizer(bufferModelConfig: Sequence[uchar], bufferWeights: Sequence[uchar]) -> Net: ...
@overload
def readNetFromONNX(onnxFile: str) -> Net: ...
@overload
def readNetFromONNX(buffer: Sequence[uchar]) -> Net: ...
@overload
def readNetFromTensorflow(model: str, config: str = ...) -> Net: ...
@overload
def readNetFromTensorflow(bufferModel: Sequence[uchar], bufferConfig: Sequence[uchar] = ...) -> Net: ...
def readNetFromTorch(model: str, isBinary: bool = ..., evaluate: bool = ...) -> Net: ...
def readTensorFromONNX(path: str) -> Mat: ...
def readTorchBlob(filename: str, isBinary: bool = ...) -> Mat: ...
def shrinkCaffeModel(src: str, dst: str, layersTypes: Sequence[str] = ...) -> None: ...
def writeTextGraph(model: str, output: str) -> None: ...
@overload
def calibrate(objectPoints: Sequence[Mat], imagePoints: Sequence[Mat], image_size: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Sequence[Mat], Sequence[Mat]]: ...
@overload
def calibrate(objectPoints: Sequence[UMat], imagePoints: Sequence[UMat], image_size: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, Sequence[UMat], Sequence[UMat]]: ...
@overload
def distortPoints(undistorted: Mat, K: Mat, D: Mat, alpha: float = ...) -> Mat: ...
@overload
def distortPoints(undistorted: UMat, K: UMat, D: UMat, alpha: float = ...) -> UMat: ...
@overload
def estimateNewCameraMatrixForUndistortRectify(K: Mat, D: Mat, image_size: Size, R: Mat, balance: float = ..., new_size: Size = ..., fov_scale: float = ...) -> Mat: ...
@overload
def estimateNewCameraMatrixForUndistortRectify(K: UMat, D: UMat, image_size: Size, R: UMat, balance: float = ..., new_size: Size = ..., fov_scale: float = ...) -> UMat: ...
@overload
def initUndistortRectifyMap(K: Mat, D: Mat, R: Mat, P: Mat, size: Size, m1type: int) -> Tuple[Mat, Mat]: ...
@overload
def initUndistortRectifyMap(K: UMat, D: UMat, R: UMat, P: UMat, size: Size, m1type: int) -> Tuple[UMat, UMat]: ...
@overload
def projectPoints(objectPoints: Mat, rvec: Mat, tvec: Mat, K: Mat, D: Mat, alpha: float = ...) -> Tuple[Mat, Mat]: ...
@overload
def projectPoints(objectPoints: UMat, rvec: UMat, tvec: UMat, K: UMat, D: UMat, alpha: float = ...) -> Tuple[UMat, UMat]: ...
@overload
def stereoCalibrate(objectPoints: Sequence[Mat], imagePoints1: Sequence[Mat], imagePoints2: Sequence[Mat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, Mat, Mat, Mat, Mat, Mat, Mat]: ...
@overload
def stereoCalibrate(objectPoints: Sequence[UMat], imagePoints1: Sequence[UMat], imagePoints2: Sequence[UMat], imageSize: Size, flags: int = ..., criteria: TermCriteria = ...) -> Tuple[TermCriteria, UMat, UMat, UMat, UMat, UMat, UMat]: ...
@overload
def stereoRectify(K1: Mat, D1: Mat, K2: Mat, D2: Mat, imageSize: Size, R: Mat, tvec: Mat, flags: int, newImageSize: Size = ..., balance: float = ..., fov_scale: float = ...) -> Tuple[Mat, Mat, Mat, Mat, Mat]: ...
@overload
def stereoRectify(K1: UMat, D1: UMat, K2: UMat, D2: UMat, imageSize: Size, R: UMat, tvec: UMat, flags: int, newImageSize: Size = ..., balance: float = ..., fov_scale: float = ...) -> Tuple[UMat, UMat, UMat, UMat, UMat]: ...
@overload
def undistortImage(distorted: Mat, K: Mat, D: Mat, Knew: Mat = ..., new_size: Size = ...) -> Mat: ...
@overload
def undistortImage(distorted: UMat, K: UMat, D: UMat, Knew: UMat = ..., new_size: Size = ...) -> UMat: ...
@overload
def undistortPoints(distorted: Mat, K: Mat, D: Mat, R: Mat = ..., P: Mat = ...) -> Mat: ...
@overload
def undistortPoints(distorted: UMat, K: UMat, D: UMat, R: UMat = ..., P: UMat = ...) -> UMat: ...
def BGR2RGB(src: GMat) -> GMat: ...
def RGB2Gray(src: GMat) -> GMat: ...
def add(src1: GMat, src2: GMat, ddepth: int = ...) -> GMat: ...
def addC(src1: GMat, c: GScalar, ddepth: int = ...) -> GMat: ...
@overload
def boundingRect(src: GMat) -> GOpaque<Rect>: ...
@overload
def boundingRect(src: GArray_Point2i) -> GOpaque<Rect>: ...
@overload
def goodFeaturesToTrack(image: GMat, maxCorners: int, qualityLevel: float, minDistance: float, mask: Mat = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> GArray<Point2f>: ...
@overload
def goodFeaturesToTrack(image: GMat, maxCorners: int, qualityLevel: float, minDistance: float, mask: Mat = ..., blockSize: int = ..., useHarrisDetector: bool = ..., k: float = ...) -> GArray<Point2f>: ...
@overload
def infer(name: str, inputs: GInferInputs) -> GInferOutputs: ...
@overload
def infer(name: str, roi: GOpaque_Rect, inputs: GInferInputs) -> GInferOutputs: ...
@overload
def infer(name: str, rois: GArray_Rect, inputs: GInferInputs) -> GInferListOutputs: ...
def infer2(name: str, in: GMat, inputs: GInferListInputs) -> GInferListOutputs: ...
@overload
def kmeans(data: GMat, K: int, criteria: TermCriteria, attempts: int, flags: KmeansFlags) -> Tuple[GOpaque<double>, GMat, GMat]: ...
@overload
def kmeans(data: GArray_Point2f, K: int, bestLabels: GArray_int, criteria: TermCriteria, attempts: int, flags: KmeansFlags) -> Tuple[GOpaque<double>, GArray<int>, GArray<Point2f>]: ...
def mean(src: GMat) -> GScalar: ...
def medianBlur(src: GMat, ksize: int) -> GMat: ...
def parseSSD(in: GMat, inSz: GOpaque_Size, confidenceThreshold: float = ..., alignmentToSquare: bool = ..., filterOutOfBounds: bool = ...) -> GArray<Rect>: ...
def resize(src: GMat, dsize: Size, fx: float = ..., fy: float = ..., interpolation: int = ...) -> GMat: ...
def split3(src: GMat) -> Tuple[GMat, GMat, GMat]: ...
def threshold(src: GMat, maxval: GScalar, type: int) -> Tuple[GMat, GScalar]: ...
def kernels() -> gapi_GKernelPackage: ...
def kernels() -> gapi_GKernelPackage: ...
def kernels() -> gapi_GKernelPackage: ...
@overload
def params(tag: str, model: str, weights: str, device: str) -> PyParams: ...
@overload
def params(tag: str, model: str, device: str) -> PyParams: ...
@overload
def size(src: GMat) -> GOpaque<Size>: ...
@overload
def size(r: GOpaque_Rect) -> GOpaque<Size>: ...
def make_capture_src(path: str) -> IStreamSource: ...
def getIppVersion() -> str: ...
def setUseIPP(flag: bool) -> None: ...
def setUseIPP_NotExact(flag: bool) -> None: ...
def useIPP() -> bool: ...
def useIPP_NotExact() -> bool: ...
def ANN_MLP_create() -> ANN_MLP: ...
def ANN_MLP_load(filepath: str) -> ANN_MLP: ...
def Boost_create() -> Boost: ...
def Boost_load(filepath: str, nodeName: str = ...) -> Boost: ...
def DTrees_create() -> DTrees: ...
def DTrees_load(filepath: str, nodeName: str = ...) -> DTrees: ...
def EM_create() -> EM: ...
def EM_load(filepath: str, nodeName: str = ...) -> EM: ...
def KNearest_create() -> KNearest: ...
def KNearest_load(filepath: str) -> KNearest: ...
def LogisticRegression_create() -> LogisticRegression: ...
def LogisticRegression_load(filepath: str, nodeName: str = ...) -> LogisticRegression: ...
def NormalBayesClassifier_create() -> NormalBayesClassifier: ...
def NormalBayesClassifier_load(filepath: str, nodeName: str = ...) -> NormalBayesClassifier: ...
def ParamGrid_create(minVal: float = ..., maxVal: float = ..., logstep: float = ...) -> ParamGrid: ...
def RTrees_create() -> RTrees: ...
def RTrees_load(filepath: str, nodeName: str = ...) -> RTrees: ...
def SVMSGD_create() -> SVMSGD: ...
def SVMSGD_load(filepath: str, nodeName: str = ...) -> SVMSGD: ...
def SVM_create() -> SVM: ...
def SVM_getDefaultGridPtr(param_id: int) -> ParamGrid: ...
def SVM_load(filepath: str) -> SVM: ...
@overload
def TrainData_create(samples: Mat, layout: int, responses: Mat, varIdx: Mat = ..., sampleIdx: Mat = ..., sampleWeights: Mat = ..., varType: Mat = ...) -> TrainData: ...
@overload
def TrainData_create(samples: UMat, layout: int, responses: UMat, varIdx: UMat = ..., sampleIdx: UMat = ..., sampleWeights: UMat = ..., varType: UMat = ...) -> TrainData: ...
@overload
def TrainData_getSubMatrix(matrix: Mat, idx: Mat, layout: int) -> Mat: ...
@overload
def TrainData_getSubMatrix(matrix: Mat, idx: Mat, layout: int) -> Mat: ...
@overload
def TrainData_getSubVector(vec: Mat, idx: Mat) -> Mat: ...
@overload
def TrainData_getSubVector(vec: Mat, idx: Mat) -> Mat: ...
def Device_getDefault() -> Device: ...
def finish() -> None: ...
def haveAmdBlas() -> bool: ...
def haveAmdFft() -> bool: ...
def haveOpenCL() -> bool: ...
def setUseOpenCL(flag: bool) -> None: ...
def useOpenCL() -> bool: ...
def setParallelForBackend(backendName: str, propagateNumThreads: bool = ...) -> bool: ...
def addSamplesDataSearchPath(path: str) -> None: ...
def addSamplesDataSearchSubDirectory(subdir: str) -> None: ...
def findFile(relative_path: str, required: bool = ..., silentMode: bool = ...) -> str: ...
def findFileOrKeep(relative_path: str, silentMode: bool = ...) -> str: ...
def dumpBool(argument: bool) -> str: ...
def dumpCString(argument: str) -> str: ...
def dumpDouble(argument: float) -> str: ...
def dumpFloat(argument: float) -> str: ...
@overload
def dumpInputArray(argument: Mat) -> str: ...
@overload
def dumpInputArray(argument: UMat) -> str: ...
@overload
def dumpInputArrayOfArrays(argument: Sequence[Mat]) -> str: ...
@overload
def dumpInputArrayOfArrays(argument: Sequence[UMat]) -> str: ...
@overload
def dumpInputOutputArray() -> Tuple[Mat, Mat]: ...
@overload
def dumpInputOutputArray() -> Tuple[UMat, UMat]: ...
@overload
def dumpInputOutputArrayOfArrays() -> Tuple[Sequence[Mat], Sequence[Mat]]: ...
@overload
def dumpInputOutputArrayOfArrays() -> Tuple[Sequence[UMat], Sequence[UMat]]: ...
def dumpInt(argument: int) -> str: ...
def dumpRange(argument: Range) -> str: ...
def dumpRect(argument: Rect) -> str: ...
def dumpRotatedRect(argument: RotatedRect) -> str: ...
def dumpSizeT(argument: int) -> str: ...
def dumpString(argument: str) -> str: ...
def dumpTermCriteria(argument: TermCriteria) -> str: ...
@overload
def testAsyncArray(argument: Mat) -> AsyncArray: ...
@overload
def testAsyncArray(argument: UMat) -> AsyncArray: ...
def testAsyncException() -> AsyncArray: ...
@overload
def testOverloadResolution(value: int, point: Point = ...) -> str: ...
@overload
def testOverloadResolution(rect: Rect) -> str: ...
def testRaiseGeneralException() -> None: ...
def getCacheDirectoryForDownloads() -> str: ...
def getBackendName(api: VideoCaptureAPIs) -> str: ...
def getBackends() -> Sequence[VideoCaptureAPIs]: ...
def getCameraBackendPluginVersion(api: VideoCaptureAPIs) -> Tuple[int, int, int]: ...
def getCameraBackends() -> Sequence[VideoCaptureAPIs]: ...
def getStreamBackendPluginVersion(api: VideoCaptureAPIs) -> Tuple[int, int, int]: ...
def getStreamBackends() -> Sequence[VideoCaptureAPIs]: ...
def getWriterBackendPluginVersion(api: VideoCaptureAPIs) -> Tuple[int, int, int]: ...
def getWriterBackends() -> Sequence[VideoCaptureAPIs]: ...
def hasBackend(api: VideoCaptureAPIs) -> bool: ...
def isBackendBuiltIn(api: VideoCaptureAPIs) -> bool: ...
